{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bases de datos","text":""},{"location":"#sql","title":"SQL","text":"<p>Es el acr\u00f3nimo de Structured Query Language </p> <p>Lenguaje de Consultas Estructuradas</p> <p>Es un lenguaje de programaci\u00f3n y est\u00e1 estandarizado.</p> <p>Usos:</p> <ul> <li>consultar datos;</li> <li> <p>restricciones y reglas de integridad</p> </li> <li> <p>optimizar </p> </li> <li> <p>generar informes</p> </li> <li>realizar analisis de datos</li> <li>administrar usuarios y permisos</li> <li>transacciones</li> <li>copias de seguridad</li> <li>integrar con aplicaciones</li> <li>limpieza de datos</li> <li>normalizacion de datos</li> <li>calculo avanzado</li> <li>combinacion de datos</li> <li>optimizacion de rendimiento</li> </ul> <p>Recomendado:</p> <p>Tener a mano la base de datos Northwind para la pr\u00e1ctica.</p>"},{"location":"tags/","title":"Etiquetas","text":"<p>Todas las etiquetas usadas en el proyecto aparecen aqu\u00ed.</p>"},{"location":"tags/#tag:mariadb","title":"MariaDB","text":"<ul> <li>            Agrupar (Group by)          </li> <li>            Diferencias y Migraci\u00f3n          </li> <li>            Funciones Definidas por el Usuario (UDF)          </li> <li>            Identificadores          </li> <li>            Instalaci\u00f3n          </li> <li>            Normalizaci\u00f3n          </li> <li>            NorthWind          </li> <li>            Procedimientos almacenados (Stored Procedures)          </li> <li>            Subconsultas          </li> <li>            Tablas y Datos          </li> <li>            Uniones (Joins)          </li> <li>            Uso en Python          </li> <li>            Vistas          </li> <li>            \u00cdndices          </li> </ul>"},{"location":"tags/#tag:mysql","title":"MySQL","text":"<ul> <li>            Agrupar (Group by)          </li> <li>            Diferencias y Migraci\u00f3n          </li> <li>            Funciones Definidas por el Usuario (UDF)          </li> <li>            Identificadores          </li> <li>            Instalaci\u00f3n          </li> <li>            Normalizaci\u00f3n          </li> <li>            NorthWind          </li> <li>            Procedimientos almacenados (Stored Procedures)          </li> <li>            Subconsultas          </li> <li>            Tablas y Datos          </li> <li>            Uniones (Joins)          </li> <li>            Uso en Python          </li> <li>            Vistas          </li> <li>            \u00cdndices          </li> </ul>"},{"location":"tags/#tag:postgresql","title":"PostgreSQL","text":"<ul> <li>            Agrupar (Group by)          </li> <li>            Diferencias y Migraci\u00f3n          </li> <li>            Funciones Definidas por el Usuario (UDF)          </li> <li>            Identificadores          </li> <li>            Instalaci\u00f3n          </li> <li>            Normalizaci\u00f3n          </li> <li>            NorthWind          </li> <li>            Procedimientos almacenados (Stored Procedures)          </li> <li>            Subconsultas          </li> <li>            Tablas y Datos          </li> <li>            Uniones (Joins)          </li> <li>            Uso en Python          </li> <li>            Vistas          </li> <li>            \u00cdndices          </li> </ul>"},{"location":"tags/#tag:python","title":"Python","text":"<ul> <li>            Funciones Definidas por el Usuario (UDF)          </li> <li>            Uso en Python          </li> </ul>"},{"location":"tags/#tag:sqlalchemy","title":"SQLAlchemy","text":"<ul> <li>            Funciones Definidas por el Usuario (UDF)          </li> <li>            Normalizaci\u00f3n          </li> <li>            Procedimientos almacenados (Stored Procedures)          </li> <li>            Uniones (Joins)          </li> <li>            Uso en Python          </li> <li>            Vistas          </li> <li>            \u00cdndices          </li> </ul>"},{"location":"tags/#tag:sqlite","title":"SQLite","text":"<ul> <li>            Agrupar (Group by)          </li> <li>            Bloqueos y Transacciones          </li> <li>            Cl\u00e1usulas Condicionales          </li> <li>            Consultas          </li> <li>            Diferencias y Migraci\u00f3n          </li> <li>            Funciones Definidas por el Usuario (UDF)          </li> <li>            Funciones de Agregaci\u00f3n          </li> <li>            Identificadores          </li> <li>            Instalaci\u00f3n          </li> <li>            Normalizaci\u00f3n          </li> <li>            NorthWind          </li> <li>            Ordenar campos          </li> <li>            Procedimientos almacenados (Stored Procedures)          </li> <li>            Subconsultas          </li> <li>            Tablas y Datos          </li> <li>            Uniones (Joins)          </li> <li>            Uso en Python          </li> <li>            Vistas          </li> <li>            \u00cdndices          </li> </ul>"},{"location":"anexos/northwind/","title":"Anexo - NorthWind","text":"<p>Para mayor comodidad de uso se adjunta la base de datos Northwind adaptada para los gestores de base de datos m\u00e1s populares.</p> SQLiteMySQL / MariaDBPostgreSQLSQL Server <p>Ver c\u00f3digo online desde Wikiversity</p> <p>Descargar script (.sql)</p> <p>Ver c\u00f3digo online desde Wikiversity</p> <p>Descargar script (.sql)</p> <p>Ver c\u00f3digo online desde Wikiversity</p> <p>Descargar script (.sql)</p> <p>Ver c\u00f3digo online desde Wikiversity</p> <p>Descargar script (.sql)</p> <p>C\u00f3digo extra\u00eddo de Wikiversity con licencia Creative Commons BY-SA 4.0</p> <p>Diagrama Entidad-Estado (ER):</p> <pre><code>erDiagram\n\n    Customers ||--|{ Orders : CustomerID    \n    Employees ||--|{ Orders : EmployeeID    \n    Shippers  ||--|{ Orders : ShipperID \n\n    Orders ||--|{ OrderDetails : OrderID    \n\n    OrderDetails }|--|| Products: ProductID\n\n    Products }|--|| Categories: CategoryID  \n    Products }|--|| Suppliers: SupplierID\n\n    Orders{\n        INT OrderID \n        INT CustomerID  \n        INT EmployeeID  \n        DATETIME OrderDate  \n        INT ShipperID\n    }\n    OrderDetails{\n        INT OrderDetailID   \n        INT OrderID \n        INT ProductID   \n        INT Quantity\n    }\n    Products{\n        INT ProductID\n        TEXT ProductName    \n        INT SupplierID  \n        INT CategoryID  \n        TEXT Unit   \n        NUMERIC Price\n    }\n    Employees{\n        INT EmployeeID\n        TEXT LastName\n        TEXT FirstName\n        DATE BirthDate\n        TEXT Photo\n        TEXT Notes\n    }\n    Categories{\n        INT CategoryID\n        TEXT CategoryName\n        TEXT Description\n    }\n    Customers{\n        INT CustomerID  \n        TEXT CustomerName   \n        TEXT ContactName    \n        TEXT Address    \n        TEXT City   \n        TEXT PostalCode \n        TEXT Country\n    }\n    Shippers{\n        INT ShipperID\n        TEXT ShipperName    \n        TEXT Phone\n    }\n    Suppliers{\n        INT SupplierID\n        TEXT SupplierName\n        TEXT ContactName\n        TEXT Address\n        TEXT City\n        TEXT PostalCode\n        TEXT Country\n        TEXT Phone\n    }</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/bloqueos_transacciones/","title":"Bloqueos y Transacciones","text":"<p>Los bloqueos son un mecanismo preventivo de las bases de datos que impiden m\u00faltiples consultas simult\u00e1neas. Esto permite asegurar la integridad de los datos y prevenir tanto errores de lectura como de escritura.</p> <p>SQLite utiliza bloqueo completo mientras se realiza una operacion de escritura, en tanto que permite lecturas concurrentes.</p> <p>Tipos de bloqueos:</p> <ul> <li> <p>Bloqueos compartidos (shared locks) Mientras se lee se permiten lecturas pero no escrituras. S\u00f3lo se puede escribir cuando nadie est\u00e9 leyendo la data.</p> </li> <li> <p>Bloqueos reservados (reserved locks)  Mientras se escribe se permiten lecturas pero no escrituras. Se impiden escrituras solapadas;  en cambio se permite leer datos cambiantes.</p> </li> <li> <p>Bloqueos exclusivos (exclusive locks) Mientras se escribe se impiden tanto lecturas como escrituras.</p> </li> </ul> <p>Las transacciones son cambios vol\u00e1tiles que se pueden asentar permanentemente (commit) o deshacer (rollback). </p> <p>La transacci\u00f3n siempre comienza con el comando <code>BEGIN</code>:</p> <pre><code>-- Comienza una transaccion\nBEGIN;\n-- Se propone un cambio en ciertos registros. El cambio es temporal\nUPDATE Products SET ProductName = \"El Pollo\" WHERE ProductName = \"Chais\" ;\n</code></pre> <p>Si se detecta alg\u00fan error o inconsistencia en los cambios realizados se puede ordenar el paso atr\u00e1s con el comando <code>ROLLBACK</code>:</p> <pre><code>-- Deshace los cambios\nROLLBACK\n</code></pre> <p>Si en cambio se busca guardar los cambios de forma definitiva se utiliza el comando <code>COMMIT</code>:</p> <p><pre><code>-- Asienta los cambios en la base de datos\nCOMMIT\n</code></pre> Las transacciones son indispensables para trabajar sobre las bases de datos desde programas externos.</p>","tags":["SQLite"]},{"location":"sql/cardinalidad/","title":"Cardinalidad","text":""},{"location":"sql/cardinalidad/#cardinalidad","title":"Cardinalidad","text":"<ul> <li>1:1 uno a uno</li> <li>1:n uno a muchos</li> <li>n:1 muchos a uno</li> <li>n:m muchos a muchos</li> </ul> <p>Para manejar relaciones n:m se crean tablas intermedias. La tabla intermedia se relacionar\u00e1 n:1 con la primera tabla y 1:n con la segunda tabla.</p>"},{"location":"sql/cardinalidad/#ver-esquema-martin","title":"VER ESQUEMA MARTIN","text":"<p>Esta notaci\u00f3n permite indicar la cardinalidad entre tablas con una l\u00ednea con terminaci\u00f3n especial:</p> <p>Opciones:</p> <ul> <li>One</li> <li>Many</li> <li>One (and only one)</li> <li>Zero or one</li> <li>One or many</li> <li>Zero or many</li> </ul>"},{"location":"sql/chen/","title":"Modelo Entidad-Relacion (ER)","text":""},{"location":"sql/chen/#notacion-de-chen","title":"Notacion de Chen","text":""},{"location":"sql/chen/#entidad","title":"Entidad","text":"<p>Es una representacion de algo. Normalmente se almacena como tabla.</p> <p>En esta notacion las entidades se representan como una palabra dentro de un rectangulo.</p>"},{"location":"sql/chen/#atributos","title":"Atributos","text":"<p>Una entidad tiene multiples atributos. Los atributos se representan gr\u00e1ficamente con \u00f3valos.</p> <p>Los atributos comunes pueden ser simples o compuestos.  Los atributos simples tienen un dato \u00fanico cada uno</p> <p>Los atributos compuestos \u00e9st\u00e1n formados por otros atributos. </p> <p>Los atibutos simples se representan con \u00f3valos vac\u00edos (\"huecos\"), en tanto que los atributos compuestos se representan con ovalos rellenos.</p> <p>Tambien existen los atributos multivalor, los cuales tienen multiples valores asignados. Los atributos multivalor se representan con un \u00f3valo doble.</p> <p>Los atributos derivados se pueden obtener a partir de otros atributos. Se representan con \u00f3valos punteados.</p>"},{"location":"sql/chen/#key-clave","title":"Key (clave)","text":"<p>Las keys son atributos \u00fanicos e irrepetibles. Se marcan con un subrayado.</p>"},{"location":"sql/condicionales/","title":"Cl\u00e1usulas Condicionales","text":"<p>Las cl\u00e1usulas condicionales se utilizan con ayuda de la cl\u00e1usula <code>WHERE</code>, la cual permite seleccionar registros de las tablas en base a criterios espec\u00edficos. Pueden afectar a la lectura de datos (<code>SELECT</code>),  a la actualizaci\u00f3n (<code>UPDATE</code>)  y a la eliminaci\u00f3n (<code>DELETE</code>).</p>","tags":["SQLite"]},{"location":"sql/condicionales/#select","title":"SELECT","text":"","tags":["SQLite"]},{"location":"sql/condicionales/#por-coincidencia-numerica","title":"por coincidencia num\u00e9rica","text":"<pre><code>SELECT * FROM Products \nWHERE ProductID = 24;\n</code></pre> <p>Resultado: el producto con ID 24</p> ProductID ProductName SupplierID CategoryID Unit Price 24 Guaran\u00e1 Fant\u00e1stica 10 1 12 - 355 ml cans 4.5","tags":["SQLite"]},{"location":"sql/condicionales/#por-texto","title":"por texto","text":"<pre><code>SELECT * FROM Products \nWHERE ProductName = \"Tofu\";\n</code></pre> <p>Resultado: el \u00fanico tofu encontrado</p> ProductID ProductName SupplierID CategoryID Unit Price 14 Tofu 6 7 40 - 100 g pkgs. 23.25","tags":["SQLite"]},{"location":"sql/condicionales/#por-rango-numerico","title":"por rango num\u00e9rico","text":"<p><pre><code>SELECT * FROM Products \nWHERE Price &lt;= 40; --menor o igual a 4\n</code></pre> Resultado: 77 registros con precio unitario menor a 40</p> ProductID ProductName SupplierID CategoryID Unit Price 1 Chais 1 1 10 boxes x 20 bags 18 2 Chang 1 1 24 - 12 oz bottles 19 3 Aniseed Syrup 1 2 12 - 550 ml bottles 10 ... 76 Lakkalik\u00f6\u00f6ri 23 1 500 ml 18 77 Original Frankfurter gr\u00fcne So\u00dfe 12 2 12 boxes 13","tags":["SQLite"]},{"location":"sql/condicionales/#delete","title":"DELETE","text":"<pre><code>DELETE FROM turnos_medicos \nWHERE id_turno = 2 ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#update","title":"UPDATE","text":"<pre><code>UPDATE turnos_medicos SET horario = \"13:00\" \nWHERE id_turno = 1 ; \n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"","tags":["SQLite"]},{"location":"sql/condicionales/#and","title":"AND","text":"<pre><code>SELECT * FROM Customers\nWHERE CustomerID &gt;= 50 AND CustomerID &lt; 55 ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#or","title":"OR","text":"<pre><code>SELECT * FROM Employees\nWHERE FirstName =\"Janet\" OR FirstName = \"Adam\" ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#not","title":"NOT","text":"<pre><code>SELECT * FROM Customers\nWHERE NOT Country = \"USA\" ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#combinados-con-parentesis","title":"Combinados con par\u00e9ntesis","text":"<pre><code>SELECT * FROM Products\nWHERE (Price &lt; 20  OR CategoryID = 6) AND SupplierID = 7 ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#limit","title":"LIMIT","text":"<p>Con la cl\u00e1usula LIMIT se puede poner tope al numero de resultados: <pre><code>SELECT * FROM Customers\nWHERE CustomerID &gt;=50\nLIMIT 5 ;\n</code></pre></p> <p>Ejemplo: cl\u00e1usulas combinadas <pre><code>SELECT * FROM Products\nWHERE NOT CategoryID = 6 \nAND NOT SupplierID = 1\nAND Price &lt;= 30\nORDER BY RANDOM()\nLIMIT 5 ;\n</code></pre></p>","tags":["SQLite"]},{"location":"sql/condicionales/#distinct","title":"DISTINCT","text":"<pre><code>SELECT * FROM Customers\nWHERE  Country != \"USA\" ;\n</code></pre> <p>El operador <code>DISTINCT</code> (<code>!=</code>) es un operador de comparaci\u00f3n. NO cuenta como operador l\u00f3gico.</p>","tags":["SQLite"]},{"location":"sql/condicionales/#between","title":"BETWEEN","text":"<p>El operador <code>BETWEEN</code> facilita elegir campos en un rango de valores.</p> <pre><code>SELECT * FROM Products \nWHERE Price BETWEEN 20 AND 40 ;\n</code></pre> <pre><code>SELECT * FROM Products \nWHERE Price BETWEEN 20 AND 40\nAND CategoryID = 6 ;\n</code></pre> <p>Este operador es pr\u00e1ctico para seleccionar entre fechas</p> <pre><code>SELECT * FROM Employees\nWHERE BirthDate BETWEEN \"1960-0-1\" AND \"1970-01\" ;\n</code></pre> <p>Valores l\u00edmite</p> <p>Los valores l\u00edmite de <code>BETWEEN</code> est\u00e1n incluidos.  Adem\u00e1s estos deben cumplir:</p> <ul> <li>estar ordenados de menor a mayor;</li> <li>ser de tipo compatible  (hay que evitar mezcla de criterios).</li> </ul>","tags":["SQLite"]},{"location":"sql/condicionales/#like","title":"LIKE","text":"<p>La cl\u00e1usula <code>LIKE</code> se porta como un operador igualdad:</p> <p><pre><code>SELECT * FROM Employees\nWHERE LastName LIKE \"Fuller\" ;\n</code></pre> La ventaja es el potencial de usar caracteres comod\u00edn para implementar la b\u00fasqueda de patrones.</p>","tags":["SQLite"]},{"location":"sql/condicionales/#comodin","title":"Comodin <code>%</code>","text":"<pre><code>-- Apellidos que empiezan con \"D\"\nSELECT * FROM Employees\nWHERE LastName LIKE \"D%\" ;\n</code></pre> <pre><code>-- Apellidos que terminan con \"G\"\nSELECT * FROM Employees\nWHERE LastName LIKE \"%G\" ;\n</code></pre> <pre><code>-- Apellidos que incluyen la \"A\"\nSELECT * FROM Employees\nWHERE LastName LIKE \"%A%\" ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#comodin-_","title":"Comodin <code>_</code>","text":"<pre><code>-- Apellidos que coinciden con el patr\u00f3n\nSELECT * FROM Employees\n-- Empieza con \"F\", 4 espacios en medio, termina en \"R\"\nWHERE LastName LIKE \"F____R\" ; \n</code></pre> <pre><code>-- Apellidos que coinciden con el patr\u00f3n\nSELECT * FROM Employees\n-- 1 espacio al inicio, 1 \"U\", 4 espacios al final\nWHERE LastName LIKE \"_U____\" ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#comodines-combinados","title":"Comodines combinados","text":"<pre><code>-- Apellidos que coinciden con el patr\u00f3n\nSELECT * FROM Employees\n-- 1 espacio al inicio, 1 \"U\", al menos 5 letras\nWHERE LastName LIKE \"_U___%\" ; \n</code></pre>","tags":["SQLite"]},{"location":"sql/condicionales/#is","title":"IS","text":"<p>Con el operador <code>IS</code> se puede filtrar tanto a los registros con valor nulos como a los no nulos.</p> <p>nulos<pre><code>-- Registros con valor nulo\nSELECT * FROM Products\nWHERE ProductName IS NULL;\n</code></pre> no nulos<pre><code>-- Registros con valores no nulos\nSELECT * FROM Products\nWHERE ProductName IS NOT NULL;\n</code></pre></p>","tags":["SQLite"]},{"location":"sql/condicionales/#in","title":"IN","text":"<p>El operador <code>IN</code> sirve para aquellos casos en que se necesita seleccionar muchos valores particulares de un par\u00e1metro.</p> <p>Por ejemplo: valores 3,4,9 <pre><code>SELECT * FROM Products\nWHERE SupplierID = 3\nOR SupplierID = 4\nOR SupplierID = 9;\n</code></pre></p> <p>Con el operador <code>IN</code> se reduce a:</p> <pre><code>SELECT * FROM Products\nWHERE SupplierID IN (3, 4, 9);\n</code></pre> <p>Los valores de inter\u00e9s se agrupan por par\u00e9ntesis y se separan con comas.</p> <p><code>IN</code> es considerado un operador l\u00f3gico por sustituir la bater\u00eda de operadores <code>OR</code> que aglomeraban los condicionales de relaci\u00f3n para cada valor.</p> <p>Los valores buscados pueden ser textos: <pre><code>SELECT * FROM Employees\nWHERE LastName IN (\"King\",\"Fuller\") ;\n</code></pre> Con el operador <code>NOT</code> se puede invertir el resultado,  excluyendo los casos elegidos: <pre><code>SELECT * FROM Employees\nWHERE LastName NOT IN (\"King\",\"Fuller\") ;\n</code></pre></p>","tags":["SQLite"]},{"location":"sql/diferencias_migracion/","title":"Diferencias entre gestores - Migraci\u00f3n","text":"","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#caracteristicas-de-los-gestores","title":"Caracter\u00edsticas de los gestores","text":"","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#sqlite","title":"SQLite","text":"<ul> <li>Es un gestor embebido</li> <li>Trabaja con archivo \u00fanico</li> <li>Es ideal para aplicaciones embebidas y prototipos</li> <li>No sirve para aplicaciones de gran escala o de alto rendimiento</li> </ul>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#mysql","title":"MySQL","text":"<ul> <li>Es un gestor basado en servidor</li> <li>Puede trabajar con m\u00faltiples archivos</li> <li>Es ideal para aplicaciones de gran escala o de alto rendimiento</li> </ul>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#postgresql","title":"PostgreSQL","text":"<ul> <li>Es un gestor basado en servidor</li> <li>Puede trabajar con m\u00faltiples archivos</li> <li>Es ideal para aplicaciones de gran escala o de alto rendimiento</li> <li>Tiene extensiones propias</li> </ul>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#sqlserver","title":"SQLServer","text":"<ul> <li>Es de pago</li> <li>Es un gestor basado en servidor</li> <li>Puede trabajar con m\u00faltiples archivos</li> <li>Es ideal para aplicaciones de gran escala o de alto rendimiento</li> <li>Tiene extensiones propias</li> </ul>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#migracion-entre-gestores","title":"Migracion entre gestores","text":"<p>Estructura:</p> <ul> <li>Exportar la base de datos en formato SQL;</li> <li>Abrir y modificar las consultas para adaptarla al nuevo gestor;</li> <li>Importar la base de datos modificada para crear la estructura de tablas;</li> </ul> <p>Datos:</p> <ul> <li>Exportar cada tabla, preferiblemente en formato CSV (Comma Separated Values);</li> <li> <p>Importar cada tabla en el nuevo gestor.</p> </li> <li> <p>Se adaptan las consultas para crear el formato de tablas en el nuevo gestor de base de datos;</p> </li> <li>Para migrar los datos se recomienda exportar cada tabla de la base de datos en archivos CSV e importarlos con el nuevo gestor.</li> </ul>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#comandos","title":"Comandos","text":"","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#create","title":"CREATE","text":"SQLiteMySQLSQLServerPosgreSQL <pre><code>CREATE TABLE nombre_tabla(columna1 tipo1, columna2 tipo2, ...);\n</code></pre> <pre><code>CREATE TABLE nombre_tabla(columna1 tipo1, columna2 tipo2, ...) ENGINE = InnoDB;\n</code></pre> <pre><code>CREATE TABLE nombre_tabla(columna1 tipo1, columna2 tipo2, ...);\n</code></pre> <pre><code>CREATE TABLE nombre_tabla(columna1 tipo1, columna2 tipo2, ...);\n</code></pre> <p>MySQL requiere que se indique el <code>ENGINE</code>.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#create-con-clave-primaria","title":"CREATE (con clave primaria)","text":"SQLiteMySQLSQLServerPosgreSQL <pre><code>CREATE TABLE ejemplo (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    nombre VARCHAR(50) NOT NULL, \n    apellido VARCHAR(50) NOT NULL\n)\n</code></pre> <pre><code>CREATE TABLE ejemplo(\n    id INT NOT NULL AUTO_INCREMENT,\n    nombre VARCHAR(50) NOT NULL,\n    apellido VARCHAR(50) NOT NULL,\n    PRIMARY KEY (id)\n)\n</code></pre> <pre><code>CREATE TABLE ejemplo(\n    id INT IDENTITY(1,1) PRIMARY KEY, \n    nombre VARCHAR(50) NOT NULL,\n    apellido VARCHAR(50) NOT NULL,\n)\n</code></pre> <pre><code>CREATE TABLE nombre_tCREATE TABLE ejemplo(\n    id SERIAL PRIMARY KEY ,\n    nombre VARCHAR(50) NOT NULL,\n    apellido VARCHAR(50) NOT NULL\n)\n</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#right-join","title":"RIGHT JOIN","text":"SQLiteMySQLSQLServerPosgreSQL <pre><code>SELECT * FROM tabla2 LEFT JOIN tabla1\nON tabla2.columna = tabla1.columna;\n</code></pre> <pre><code>SELECT * FROM tabla1 RIGHT JOIN tabla2\nON tabla1.columna = tabla2.columna;\n</code></pre> <pre><code>SELECT * FROM tabla1 RIGHT JOIN tabla2\nON tabla1.columna = tabla2.columna;\n</code></pre> <pre><code>SELECT * FROM tabla1 RIGHT JOIN tabla2\nON tabla1.columna = tabla2.columna;\n</code></pre> <p>El <code>RIGHT JOIN</code> no est\u00e1 implementado en SQLite.  Para los otros gestores el c\u00f3digo es igual.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#full-join","title":"Full JOIN","text":"SQLiteMySQLSQLServerPosgreSQL <pre><code>-- LEFT JOIN\nSELECT * FROM tabla1 LEFT JOIN tabla2\nON tabla1.columna = tabla2.columna;\n\nUNION\n\n-- LEFT JOIN INVERSO\nSELECT * FROM tabla2 LEFT JOIN tabla1\nON tabla2.columna = tabla1.columna;\n</code></pre> <pre><code>-- LEFT JOIN\nSELECT * FROM tabla1 LEFT JOIN tabla2\nON tabla1.columna = tabla2.columna;\n\nUNION\n\n-- RIGHT JOIN\nSELECT * FROM tabla1 RIGHT JOIN tabla2\nON tabla1.columna = tabla2.columna;\n</code></pre> <pre><code>SELECT * FROM tabla1 FULL OUTER JOIN tabla2\nON tabla1.columna = tabla2.columna;\n</code></pre> <pre><code>SELECT * FROM tabla1 FULL OUTER JOIN tabla2\nON tabla1.columna = tabla2.columna;\n</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#funcion-now","title":"Funcion NOW()","text":"<p>Esta funci\u00f3n lee la hora actual del sistema con formato</p> SQLiteMySQLSQLServerPosgreSQL <pre><code>-- REVISAR\nSELECT NOW()\n</code></pre> <pre><code>SELECT NOW()\n</code></pre> <pre><code>SELECT GETDATE()\n</code></pre> <pre><code>SELECT NOW()\n</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#ceil-y-ceiling-floor-round","title":"CEIL() y CEILING(), FLOOR(), ROUND()","text":"SQLiteMySQLSQLServerPosgreSQL <pre><code>-- REVISAR\nCEIL(numero)\n</code></pre> <pre><code>CEILING(numero)\n</code></pre> <pre><code>CEILING(numero)\n</code></pre> <pre><code>CEIL(numero)\n</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#limit","title":"LIMIT","text":"SQLiteMySQLSQLServerPosgreSQL <pre><code>SELECT * FROM tabla LIMIT n;\n</code></pre> <pre><code>SELECT * FROM tabla LIMIT n;\n</code></pre> <pre><code>SELECT TOP n * FROM tabla;\n</code></pre> <pre><code>SELECT * FROM tabla LIMIT n;\n</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#limit-con-offset","title":"LIMIT con OFFSET","text":"SQLiteMySQLSQLServerPosgreSQL <pre><code>SELECT * FROM tabla LIMIT cantidad OFFSET inicio;\n</code></pre> <pre><code>SELECT * FROM tabla LIMIT cantidad OFFSET inicio;\n</code></pre> <pre><code>SELECT * FROM (\n    SELECT *, ROW_NUMBER() OVER (ORDER BY (SELECT ALL)) AS RowNum\n    FROM tabla \n) AS Resultado\nWHERE Resultado.RowNum BETWEEN inicio + 1 AND inicio + cantidad;\n</code></pre> <pre><code>SELECT * FROM tabla LIMIT cantidad OFFSET inicio;\n</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/diferencias_migracion/#like-y-elike","title":"LIKE y ELIKE","text":"<p><code>LIKE</code> no distingue may\u00fasculas de min\u00fasculas. <code>LIKE</code> funciona igual para todos. <code>ELIKE</code> distingue may\u00fasculas de min\u00fasculas.  S\u00f3lo disponible con PosgreSQL.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/funciones_agregacion/","title":"Funciones de Agregacion","text":"<p>Las funciones de agregaci\u00f3n combinan los valores que tiene el campo de tabla especificado. Estas funciones son afectadas por la cl\u00e1usula <code>WHERE()</code>, por cuanto esta implementa el filtrado de registros  y por tanto afecta qu\u00e9 valores quedan en el campo.</p>","tags":["SQLite"]},{"location":"sql/funciones_agregacion/#count","title":"COUNT()","text":"<p><code>COUNT()</code> cuenta todos los valores disponibles del campo elegido:</p> <p>conteo<pre><code>-- Conteo de empleados\nSELECT COUNT(FirstName) FROM Employees;\n</code></pre> Resultado:</p> COUNT(FirstName) 10 conteo y asignacion de alias<pre><code>-- Conteo de empleados\nSELECT COUNT(FirstName) AS cantidad_empleados FROM Employees;\n</code></pre> <p>Resultado:</p> cantidad_empleados 10","tags":["SQLite"]},{"location":"sql/funciones_agregacion/#sum","title":"SUM()","text":"<p><code>SUM()</code> suma todos los valores disponibles del campo elegido:</p> <p>Sumatoria de valores<pre><code>-- Sumatoria de precios\nSELECT ProductName, SUM(Price) FROM Products; \n</code></pre> Resultado:</p> SUM(Price) 2222.71","tags":["SQLite"]},{"location":"sql/funciones_agregacion/#avg","title":"AVG()","text":"<p><code>AVG()</code> calcula la media aritm\u00e9tica (average) del campo seleccionado.</p> <p>promedio (average)<pre><code>-- media de precios de productos\nSELECT AVG(Price) FROM Products; \n</code></pre> Resultado:</p> AVG(Price) 28.8663636363636","tags":["SQLite"]},{"location":"sql/funciones_agregacion/#min","title":"MIN()","text":"<p>La funci\u00f3n <code>MIN()</code> elige el registro cuyo valor de campo sea el menor.</p> <p>valor minimo<pre><code>-- producto con menor precio\nSELECT ProductID, ProductName, MIN(Price) FROM Products; \n</code></pre> Resultado:</p> ProductID ProductName MIN(Price) 33 Geitost 2.5 <p>Para prevenir lecturas err\u00f3neas por valores no configurados se filtran los valores nulos:</p> <p>valor minimo - valores nulos descartados<pre><code>-- Minimo precio, con nombre e ID de producto \nSELECT ProductID, ProductName, MIN(Price) FROM Products\n-- descarte de campos nulos\nWHERE  ProductName IS NOT NULL AND Price IS NOT NULL;\n</code></pre> En este caso el resultado es el obtenido previamente</p>","tags":["SQLite"]},{"location":"sql/funciones_agregacion/#max","title":"MAX()","text":"<p>La funci\u00f3n <code>MAX()</code> elige el registro cuyo valor de campo sea el mayor.</p> valor m\u00e1ximo - valores nulos descartados<pre><code>-- Maximo precio, con nombre e ID de producto \nSELECT ProductID, ProductName, MAX(Price) FROM Products\n-- descarte de campos nulos\nWHERE  ProductName IS NOT NULL AND Price IS NOT NULL;\n</code></pre> <p>Resultado:</p> ProductID ProductName MAX(Price) 38 C\u00f4te de Blaye 263.5","tags":["SQLite"]},{"location":"sql/funciones_agregacion/#funciones-numericas","title":"Funciones num\u00e9ricas","text":"<p>Con el fin de manipular valores num\u00e9ricos se dispone de las funciones <code>ROUND()</code>, <code>FLOOR()</code>y <code>CEIL()</code> : </p> <ul> <li><code>FLOOR()</code> elimina los decimales dejando el valor entero inmediatamente inferior;</li> <li><code>CEIL()</code> empuja hacia el valor entero inmediatamente superior;</li> <li><code>ROUND()</code> redondea al n\u00famero de decimales indicado. Por defecto redonea al valor entero m\u00e1s cercano.</li> </ul> <p>Ejemplo:</p> comparativa de redondeos<pre><code>SELECT AVG(Price) AS media,\n      FLOOR(AVG(Price)) AS piso,\n    ROUND(AVG(Price), 2) AS redondeo2,\n      ROUND(AVG(Price)) AS redondeo, \n      CEIL(AVG(Price)) AS techo\nFROM Products; \n</code></pre> media piso redondeo2 redondeo techo 28.8663636363636 28.0 28.87 29.0 29.0 <p>No son de agregaci\u00f3n</p> <p>Estas funciones no son de agregaci\u00f3n, porque no combinan ni leen m\u00faltiples valores de campo sino que manipula un \u00fanico valor de entrada</p>","tags":["SQLite"]},{"location":"sql/group_by/","title":"Agrupar","text":"","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/group_by/#group-by","title":"GROUP BY","text":"<p><code>GROUP BY</code> permite \"repartir\" (agrupar) los registros le\u00eddos de una tabla en base a los valores de un campo elegido. Como analog\u00eda, es como si este comando creara varias tablas paralelas que se reparten las filas entre s\u00ed. Una vez reordenadas las filas se aplica la funci\u00f3n de agregaci\u00f3n elegida de manera paralela para cada grupo,  obteni\u00e9ndose un resultado separado para cada grupo.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/group_by/#uso-basico","title":"Uso b\u00e1sico","text":"<p>Sup\u00f3ngase el ejemplo de la tabla <code>Products</code>,  la cual tiene 77 productos distintos. Si se buscara calcular el precio promedio de los productos seg\u00fan su proveedor:</p> Agrupado<pre><code>-- ordena los promedios de precios por proveedor\nSELECT SupplierID, ROUND(AVG(Price),2) AS promedio FROM Products \n-- GROUP BY clasifica los registros\nGROUP BY SupplierID\n</code></pre> <p>entonces la funci\u00f3n <code>AVG()</code> usada calcular\u00e1 un promedio independiente para cada uno de los 29 proveedores disponibles:</p> SupplierID promedio 1 15.67 2 20.35 3 31.67 ... ... 28 44.5 29 38.9","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/group_by/#filtrado-y-ordenado","title":"Filtrado y ordenado","text":"<p>El orden general de operaciones indicado es:</p> <ol> <li>se filtran los registros de la tabla (<code>WHERE</code>); </li> <li>se agrupan los registros en grupos <code>GROUP BY</code>;</li> <li>se ordena el resultado (<code>ORDER BY</code>);</li> <li>limitar el n\u00famero de registros de salida (<code>LIMIT</code>).</li> </ol> <p>Sup\u00f3ngase que adem\u00e1s se necesita filtrar los datos an\u00f3malos de la tabla. En tal caso se usa la cl\u00e1usula <code>WHERE</code>, la cual siempre va antes de <code>GROUP BY</code>:</p> Agrupado - con filtrado y ordenado<pre><code>SELECT SupplierID, ROUND(AVG(Price),2) as promedio FROM Products \n-- WHERE filtra por registros\nWHERE SupplierID IS NOT NULL\n-- GROUP BY clasifica los registros\nGROUP BY SupplierID\n-- ORDER BY ordena los resultados de la funcion de agregaci\u00f3n\nORDER BY promedio\n</code></pre> <p>En este caso se obtienen los precios promedio de los 29 proveedores pero ordenados de menor a mayor:</p> SupplierID promedio 10 4.5 21 10.75 ... ... 4 46.0 18 140.75 <p>Ejemplo adicional: top 3 de ventas</p> <p>Sup\u00f3ngase que se desea conocer a los 3 productos m\u00e1s vendidos.  Entonces al agrupado y al ordenamiento se agrega la limitaci\u00f3n de resultados con el operador <code>LIMIT</code>:</p> <pre><code>-- Lectura de la tabla de ventas\nSELECT ProductID, SUM(Quantity) as Ventas FROM OrderDetails\n-- WHERE filtra por registros\nWHERE ProductID IS NOT NULL\n-- Agrupado por producto\nGROUP BY ProductID\n-- Ordenado de manera descendente - los m\u00e1s vendidos primero\nORDER BY Ventas DESC\n-- seleccion de los primeros 3 registros\nLIMIT 3\n</code></pre> <p>Resultado:</p> ProductID Ventas 31 458 60 430 35 369","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/group_by/#having","title":"HAVING","text":"<p><code>HAVING</code> habilita filtrar registros en base a operaciones realizadas sobre grupos.  Por este motivo, el <code>HAVING</code> debe ir siempre despu\u00e9s del <code>GROUP BY</code>.</p> <p>Por ejemplo, imag\u00ednese que se necesita calcular el total de ventas de una lista de productos. La tabla <code>OrderDetails</code> registra un total de 518 pedidos, donde cada pedido consta de un \u00fanico producto y su cantidad deseada por cada cliente y en cada compra:</p> conteo de registros<pre><code>-- Total de operaciones de venta registradas\nSELECT COUNT(OrderID) FROM OrderDetails\n</code></pre> <p>El total de ventas de cada producto se obtiene por agregaci\u00f3n:</p> suma total por grupo<pre><code>-- Ventas totales por producto\nSELECT ProductID, SUM(Quantity) as Ventas FROM OrderDetails\nGROUP BY ProductID\n</code></pre> <p>Donde se observa que hay 77 totales de ventas, uno por producto:</p> ProductID Ventas 1 159 2 341 3 80 ... ... 76 198 77 108 <p>Si adem\u00e1s se necesita mostrar solamente aquellos productos que superen un umbral de ventas se recurre a la cl\u00e1usula <code>HAVING</code>, a la cual se le puede agregar un ordenamiento: </p> <p>Umbral de grupos<pre><code>-- Productos con ventas por encima de un umbral\nSELECT ProductID, SUM(Quantity) as Ventas FROM OrderDetails\nGROUP BY ProductID\nHAVING Ventas &gt; 350\nORDER BY Ventas \n</code></pre> En este caso s\u00f3lo pasaron tres productos:</p> ProductID Ventas 35 369 60 430 31 458","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/group_by/#having-vs-where","title":"<code>HAVING</code> vs <code>WHERE</code>","text":"<p><code>WHERE</code> filtra sobre campos, en tanto que  <code>HAVING</code> filtra sobre el resultado de las funciones de agregaci\u00f3n.</p> <p><code>WHERE</code></p> <p><code>WHERE</code> no permite trabajar con la salida de las funciones de agregaci\u00f3n:</p> <pre><code>SELECT SupplierID, \n    AVG(Price) AS promedio \n    FROM Products \nWHERE promedio &gt; 40    -- MAL\nGROUP BY SupplierID\n</code></pre> <p><code>HAVING</code></p> <p><code>HAVING</code> est\u00e1 pensado para trabajar con la salida de las funciones de agregaci\u00f3n:</p> <pre><code>SELECT SupplierID, \n    AVG(Price) AS promedio \n    FROM Products \nGROUP BY SupplierID\nHAVING promedio &gt; 40    -- BIEN\n</code></pre> <p>Concatenar agregaciones</p> <p>No se puede concatenar funciones de agregaci\u00f3n.</p> <p>Ejemplo: </p> <pre><code>MAX(SUM( campo ) ) -- ERROR\n</code></pre> <p>Ejemplo:</p> <pre><code>-- ERROR: concatenado de funciones de agregaci\u00f3n\nSELECT ProductID, SUM(Quantity) as Ventas FROM OrderDetails\nGROUP BY ProductID\nHAVING MAX(TOTAL) -- ERROR\nORDER BY TOTAL\n</code></pre> <p>Para evitar este problema existen las subconsultas (subqueries).</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/group_by/#orden-de-clausulas","title":"Orden de cl\u00e1usulas","text":"<p>El orden general para poder especificar los distintos operadores y cl\u00e1usulas cuando hay agregaci\u00f3n es el siguiente:</p> Orden de operaciones<pre><code>-- Orden de operaciones\nSELECT ... FROM ....\nWHERE ...\nGROUP BY ...\nHAVING ...\nORDER By ...\nLIMIT ...\n</code></pre> <p>N\u00f3tese de los ejemplos previos que muchas de estas cl\u00e1usulas son de uso opcional. Sin embargo, s\u00ed es necesario respetar el orden de uso de cada una para evitar errores.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/identificadores/","title":"Identificadores","text":"","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/identificadores/#primary-key-pk","title":"Primary key (PK)","text":"<p>La clave primaria o primary key es una clave \u00fanica e irrepetible, t\u00edpicamente un numero entero.  \u00c9sta sirve como un alias de los registros de la tabla. La clave primaria se define durante la creaci\u00f3n de la tabla apuntando a uno de sus atributos internos.</p> <p>Por ejemplo, para incorporar una clave primaria a la tabla de usuarios previa:</p> Tabla usuarios - con clave primaria<pre><code>CREATE TABLE \"usuarios\" (\n    \"id_usuario\"    INTEGER,    -- atributo elegido\n    \"nombre\"    TEXT,\n    \"apellido\"  TEXT,\n    \"edad\"  INTEGER,\n    PRIMARY KEY(\"id_usuario\" AUTOINCREMENT) -- declaracion como 'primary key'\n);\n</code></pre> <p>Lo habitual es definir las claves primarias como enteros autoincrementales, de modo que su valor se asigne autom\u00e1ticamente y previniendo su repetici\u00f3n.   </p> <p>Continuando con el ejemplo se crea una segunda tabla, con sus propios campos y su propia clave primaria, esta vez para registrar los turnos m\u00e9dicos de los usuarios:</p> Tabla turnos - con clave primaria<pre><code>CREATE TABLE \"turnos_medicos\" (\n    \"id_turno\"  INTEGER,                    -- atributo PK\n    \"profesional\"   TEXT,\n    \"id_usuario\"    INTEGER,\n    \"motivo\"    TEXT,\n    \"horario\"   TEXT,\n    PRIMARY KEY(\"id_turno\" AUTOINCREMENT)   -- declaracion PK\n);\n</code></pre> <p>Los registros se cargan sin incluir un valor para la clave primaria porque \u00e9ste es asignado autom\u00e1ticamente por el gestor de la base de datos:</p> Carga de datos - primary<pre><code>INSERT INTO turnos_medicos(profesional, id_usuario, motivo, horario)\n-- el valor de la PK NO se incluye \nVALUES  ('Dr Gero', 1, 'dolor panza', '13:30')  ,   \n        ('Dr Manhattan', 3, 'dolor cabeza', '14:30') ;  \n\nSELECT * FROM turnos_medicos ;\n</code></pre> <p>El resultado es la tabla siguiente:</p> id_turno profesional id_usuario motivo horario 1 Dr Gero 1 dolor panza 13:30 2 Dr Manhattan 3 dolor cabeza 14:30","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/identificadores/#foreign-key-fk","title":"Foreign key (FK)","text":"<p>Las claves for\u00e1neas son claves de una tabla que sirven para referenciar (apuntar) a los registros de otras tablas. </p> <p>Sup\u00f3ngase quese necesita superponer dos tablas para mostrarlas juntas. Esto se hace separando por comas los nombres de tablas a mezclarse:</p> <p>Claves primarias y for\u00e1neas<pre><code>SELECT * FROM turnos_medicos , usuarios;\n</code></pre> En este ejemplo, el campo id_turno sigue siendo clave primaria,  pero dentro de la tabla se carga el campo id_usuario el cual apunta a la otra tabla.  Entonces id_usuario es en la tabla compuesta una clave for\u00e1nea (foreign key).</p> <p>Lo habitual es elegir siempre como claves for\u00e1neas a las claves primarias de otras tablas. Esto permite una referencia segura de unas tablas a otras,  porque las claves primarias son inmutables  y con ellas se evitan errores en caso de modificar los registros.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/identificadores/#alias","title":"Alias","text":"<p>Los alias funcionan como nombres alternativos para los campos de una tabla. El alias se crea en la lectura con la cl\u00e1usula <code>AS</code>.</p> <p>Sup\u00f3ngase por ejemplo base de datos Northwind para SQLite.  Si se desea llamar  <code>Apellido</code> al campo <code>LastName</code> se hace:</p> Alias - campo \u00fanico<pre><code>SELECT LastName AS Apellido FROM Employees;\n</code></pre> Apellido Davolio Fuller Leverling ... <p>En este ejemplo <code>Apellido</code> es un alias para <code>LastName</code>.</p> <p>M\u00faltiples alias pueden ser asignados en una misma lectura de datos:</p> Alias - m\u00faltiples campos<pre><code>SELECT LastName AS apellido, FirstName AS nombre FROM Employees;\n</code></pre> apellido nombre Davolio Nancy Fuller Andrew Leverling Janet ... <p>Usar alias facilita leer campos afectados por funciones.</p> <p>Por ejemplo, para leer los precios y su doble de la tabla <code>Products</code>: Alias para funciones<pre><code>SELECT Price AS precio, Price*2 AS precio_doble FROM Products;\n</code></pre></p> <p>En este caso la columna del campo <code>Price</code> se mostrar\u00e1 bajo el alias <code>precio</code> y su r\u00e9plica ya multiplicada por dos se mostrar\u00e1 bajo el alias <code>precio_doble</code>:</p> precio precio_doble 18 36 19 38 10 20 ...","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/identificadores/#resumen","title":"Resumen","text":"<ul> <li>Las primary keys son campos que identifican registros de una tabla;</li> <li>Las foreign keys son campos que apuntan a las primary keys de otras tablas;</li> <li>Los alias son apodos temporales para ciertos campos espec\u00edficos de la tabla.</li> </ul>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/indices/","title":"Indices","text":"<p>Los \u00edndices son una herramienta auxiliar que permite mejorar los tiempos de consulta para ciertos campos de inter\u00e9s. </p> <p>Los \u00edndices pueden ser:</p> <ul> <li>ordinarios</li> <li>primarios: establecen unicidad de la fila;</li> <li>\u00fanicos: aseguran que el valor del campo no se repita en otros registros;</li> <li>compuestos: previenen la repetici\u00f3n de combinaciones de valores.</li> </ul>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/indices/#creacion","title":"Creaci\u00f3n","text":"<p>Los \u00edndices se crean con la sintaxis: </p> <pre><code>CREATE INDEX &lt;alias&gt; ON &lt;tabla&gt; (&lt;campo&gt;)\n</code></pre> <p>Ejemplo: \u00edndice para los nombres de producto</p> <pre><code>-- Indice \"nombre\" apuntando al campo \"ProductName\" en tabla \"Products\"\nCREATE INDEX nombre ON Products (ProductName)\n</code></pre> <p>La consulta de campos se realiza normalmente. No se requiere usar el alias. </p> <p>Ejemplos:</p> <pre><code>SELECT * FROM Products\nSELECT * FROM Products WHERE  ProductName = \"Chais\"\n</code></pre> <p>Espacio en disco</p> <p>Los indices consumen mucho espacio en disco.  Esto se agrava cuando se necesita actualizar datos indexados.  Por ello hay que ser prudente a la hora de crear \u00edndices. </p> <p>Procesamiento</p> <p>El uso de indices exige procesamiento adicional cada vez que se actualizan las tablas.  En caso de abusarse del uso de \u00edndices, este procesamiento extra puede anular la mejora de rendimiento.</p> <p>Se recomienda crear \u00edndices para campos:</p> <ul> <li>frecuentemente accedidos;</li> <li>con alta cardinalidad. </li> </ul> <p>Claves for\u00e1enas</p> <p>Las foreign keys son campos recomendados para indexar.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/indices/#indices-unicos","title":"\u00cdndices \u00fanicos","text":"<p>Los \u00edndices sirven tambi\u00e9n como indicadores \u00fanicos para ciertos campos de inter\u00e9s,  previniento la repetici\u00f3n de valores o de combinaciones de valores.</p> Indice \u00fanico<pre><code>-- Indice unico compuesto para empleados (nombres o apellidos podr\u00edan estar repetidos)\n-- Crear este \u00edndice impedir\u00e1 la repetici\u00f3n de pares nombre - apellido\nCREATE UNIQUE INDEX name ON Employees (FirstName, LastName)\n</code></pre>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/indices/#eliminar-indices","title":"Eliminar \u00edndices","text":"<p>Los indices se eliminan con la orden <code>DROP</code>:</p> <pre><code>DROP INDEX &lt;alias&gt;\n</code></pre>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/indices/#nomenclatura-de-indices","title":"Nomenclatura de \u00edndices","text":"<p>Para ponerle nombre a los indices es habitual usar la nomenclatura:</p> <pre><code>idx_&lt;nombre_tabla&gt;_&lt;nombre_campo&gt;\n</code></pre>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/indices/#ejemplo","title":"Ejemplo","text":"<pre><code>-- Consulta con uni\u00f3n interna\nSELECT * FROM OrderDetails od\nINNER JOIN Orders o\nWHERE OrderDate &gt; \"1996-07-04\"\nAND od.Quantity &gt; 10\n\n-- Crear indices\nCREATE INDEX cantidad ON OrderDetails (Quantity);\nCREATE INDEX fecha    ON Orders (OrderDate);\n\n-- eliminar indices\nDROP INDEX cantidad ;\nDROP INDEX fecha    ;\n</code></pre>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/instalacion/","title":"Instalaci\u00f3n","text":"","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/instalacion/#instalacion","title":"Instalacion","text":"<p>gestor de base de datos (gdb)</p> <p>Recomendado: SQLite y su browser</p> <p>Instalaci\u00f3n en Windows:</p> <p>descargar los ejecutables y agregar su ruta a la variable del sistema PATH.</p> <p>Instalacion en Fedora: <pre><code>sudo dnf install sqlite # gestor base datos\nsudo dnf install sqlitebrowser # interfaz grafica\nsudo dnf install sqlite-doc\n</code></pre></p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/normalizacion/","title":"Normalizacion","text":"<p>La normalizacion  de la base de datos sirve para prevenir anomalias, mejorar el rendimiento y poder hacer consultas m\u00e1s efectivas.</p> <p>Hay cinco formas normales, cada una con sus caracter\u00edsticas. Cada nueva forma introduce requisitos adicionales a la forma anterior.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/normalizacion/#1o-forma-normal-1nf","title":"1\u00ba Forma Normal (1NF)","text":"<p>Cada celda debe tener un unico contenido at\u00f3mico. Se evita cargar la misma celda con m\u00faltiples datos o datos compuestos; en cambio se crean varios campos acordes. Cada atributo debe tener un valor \u00fanico para cada registro.</p> <p>Ejemplo tabla mal implementada:</p> ID_usuario datos_usuario 1 aqui37, Aquiles, Brinco, 37 2 helchu45, Helen, Chufe , 45 <p>Ejemplo aplicando primera forma normal:</p> ID_usuario alias nombre apellido edad 1 aqui37 Aquiles Brinco 37 2 helchu45 Helen Chufe 45","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/normalizacion/#2o-forma-normal-2nf","title":"2\u00ba Forma Normal (2NF)","text":"<p>El valor de cada celda debe depend\u00e9r unicamente de la clave primaria. (No puede haber celdas con varias claves afectando su contenido).  Se previene la dependencia parcial.</p> <p>Ejemplo tabla mal implementada:</p> ID_pedido ID_usuario ID_producto producto precio cantidad 1 34 22 galletas 1 15 <p>En este caso hay dos claves afectando el contenido del registro, que son ID_pedido e ID_producto.</p> <p>Una forma acorde a la segunda forma de implementar la tabla es:</p> ID_pedido ID_usuario ID_producto cantidad 1 34 22 15 ID_producto producto precio 22 galletas 1 <p>REVISAR</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/normalizacion/#3o-forma-normal-3nf","title":"3\u00ba Forma Normal (3NF)","text":"<p>Se busca eliminar la dependencia transitiva.  Se trata de no repetir relaciones entre campos.  Por ejemplo: en una tabla de datos de usuarios donde se indica la ciudad de su domicilio y su provincia (provincia/estado/departamento/etc) :</p> ID_usuario nombre_usuario ciudad provincia 1 Alberto La Plata Provincia de Buenos Aires 2 Claudia C\u00f3rdoba C\u00f3rdoba <p>Hay una redundancia: una misma ciudad s\u00f3lo puede estar ubicada en una \u00fanica provincia. La soluci\u00f3n es crear una tabla aparte con los datos de las ciudades, cada una con su ID y ser referenciadas por la tabla de usuarios.  </p> ID_usuario nombre_usuario ID_ciudad 1 Alberto 7 2 Claudia 21 ID_ciudad ciudad provincia 7 La Plata Provincia de Buenos Aires 21 C\u00f3rdoba C\u00f3rdoba <p>De esta forma se previene evitar la repetici\u00f3n de datos de ubicaci\u00f3n en distintas tablas.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/normalizacion/#4o-forma-normal-4nf","title":"4\u00ba Forma Normal (4NF)","text":"<p>Evita la redundancia de datos:</p> <ul> <li>multiples valores para una misma tabla</li> <li>valores dependientes de m\u00faltiples valores de la misma tabla  (dependencia muiltivaluada)</li> </ul> <p>clave foranea compuesta</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/normalizacion/#5o-forma-normal-5nf","title":"5\u00ba Forma Normal (5NF)","text":"<p>Se previenen las dependencias de union entre atributos</p> <p>Si un atributo requiere unir atributos de varias tablas entonces debe ser movido a otra tabla.</p> <p>Criterios de Normalizaci\u00f3n</p> <p>Para dise\u00f1ar bases de datos peque\u00f1as utilizar la tercera forma normal suele ser suficiente. En cambio para bases de datos muy grandes y con necesidad de escalamiento es recomendable implementar la cuarta o la quinta forma normal.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/normalizacion/#referencias","title":"Referencias","text":"<p>Soy Dalto - Curso de SQL desde CERO (Completo)</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/ordenar/","title":"Ordenado y filtrado","text":"","tags":["SQLite"]},{"location":"sql/ordenar/#order-by","title":"ORDER BY","text":"<p>El ordenamiento de datos se realiza durante la consulta con el comando <code>ORDER BY</code>. Este comando indica el campo en base al cual se har\u00e1 el ordenamiento.</p>","tags":["SQLite"]},{"location":"sql/ordenar/#asc-y-desc","title":"ASC y DESC","text":"<p>La opci\u00f3n <code>ASC</code> permite elegir el orden ascendente, en tanto que la opci\u00f3n <code>DESC</code> elige el orden descendente. El ordenamiento ser\u00e1 con orden ascendente salvo indicaci\u00f3n contraria.</p> <p>Por ejemplo, para ordenar una tabla de precios de productos en orden ascendente: ordenamiento ascendente<pre><code>SELECT * FROM Products\nORDER BY price;\n</code></pre> o: ordenamiento ascendente expl\u00edcito<pre><code>SELECT * FROM Products\nORDER BY price ASC;\n</code></pre></p> ProductID ProductName SupplierID CategoryID Unit Price 33 Geitost 15 4 500 g 2.5 24 Guaran\u00e1 Fant\u00e1stica 10 1 12 - 355 ml cans 4.5 13 Konbu 6 8 2 kg box 6 ... <p>Si en cambio se necesita ordenar en orden descendente: ordenamiento descendente<pre><code>SELECT * FROM Products\nORDER BY price DESC;\n</code></pre></p> ProductID ProductName SupplierID CategoryID Unit Price 38 C\u00f4te de Blaye 18 1 12 - 75 cl bottles 263.5 29 Th\u00fcringer Rostbratwurst 12 6 50 bags x 30 sausgs. 123.79 9 Mishi Kobe Niku 4 6 18 - 500 g pkgs. 97 ... <p>El ordenamiento se puede aplicar tambien a campos de texto, en tal caso el ordenamiento predefinido es el alfab\u00e9tico.</p>","tags":["SQLite"]},{"location":"sql/ordenar/#jerarquias-de-ordenamiento","title":"Jerarqu\u00edas de ordenamiento","text":"<p>Hay un orden de jerarqu\u00edas predefinido en el ordenamiento seg\u00fan el tipo de datos:</p> <ol> <li>Null</li> <li>N\u00fameros</li> <li>Caracteres especiales</li> <li>Letras</li> </ol> <p>La jerarqu\u00eda de ordenamiento se puede afectar con las cl\u00e1usulas <code>FIRST</code> y <code>LAST</code>. </p> <p>Ejemplo: ordenar de forma descendente pero colocando los Null al comienzo: ordenamiento descendente - Nulls al comienzo<pre><code>SELECT * FROM Products\nORDER BY ProductName DESC NULLS FIRST\n</code></pre></p> <p>Ejemplo: ordenar de forma ascendente pero colocando los Null al final: ordenamiento ascendente - Nulls al final<pre><code>SELECT * FROM Products\nORDER BY ProductName ASC NULLS LAST\n</code></pre></p>","tags":["SQLite"]},{"location":"sql/ordenar/#ordenamiento-aleatorio","title":"Ordenamiento aleatorio","text":"<p>El ordenamiento aleatorio se logra con ayuda de la funci\u00f3n <code>RANDOM()</code>:</p> ordenamiento aleatorio<pre><code>SELECT * FROM Products\nORDER BY RANDOM();\n</code></pre>","tags":["SQLite"]},{"location":"sql/ordenar/#ordenamiento-sucesivo","title":"Ordenamiento sucesivo","text":"<p>El ordenamiento por varios campos (ordenamiento sucesivo) se realiza indicando los campos uno tras otro:  ordenamiento sucesivo<pre><code>SELECT * FROM Products\nORDER BY ProductName, SupplierID;\n</code></pre></p>","tags":["SQLite"]},{"location":"sql/ordenar/#distinct","title":"DISTINCT","text":"<p>El filtrado de los valores repetidos se realiza durante la consulta con la cl\u00e1usula <code>DISTINCT</code>.</p> <p>En el ejemplo, se enumeran los IDs de todos los proveedores de una tabla de poductos: campos no repetidos<pre><code>SELECT DISTINCT SupplierID FROM Products;\n</code></pre></p> SupplierID 1 2 3 4 ... <p>Todos los IDs repetidos se ocultan.</p>","tags":["SQLite"]},{"location":"sql/procedimientos/","title":"Procedimientos almacenados (Stored Procedures)","text":"","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/procedimientos/#procedimientos-almacenados-stored-procedures","title":"Procedimientos almacenados (Stored Procedures)","text":"<p>Los procedimientos almacenados son consultas prearmadas que se pueden utilizar repetidas veces.  Son el equivalente a las funciones de los lenguajes de programaci\u00f3n.</p> <p>SQLite no soporta procedimientos almacenados debido a su tipo de armado, a diferencia de otras bases de datos como PostgreSQL, MySQL, etc.  Sin embargo esta limitaci\u00f3n puede saltearse implementando las queries prearmadas en el programa 'cliente' de la base de datos. Estas son las user defined functions, las cuales se explican m\u00e1s adelante.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/query/","title":"Consultas","text":"","tags":["SQLite"]},{"location":"sql/query/#query","title":"Query","text":"<p>Las queries (consultas) son todas las operaciones que afectan a la base de datos.</p>","tags":["SQLite"]},{"location":"sql/query/#comentarios","title":"Comentarios","text":"<p>Los comentarios y la anulaci\u00f3n de l\u00edneas de c\u00f3digo SQL se realizan con doble gui\u00f3n (<code>--</code>) al inicio de la l\u00ednea:</p> Comentarios<pre><code>-- texto del commentario\n</code></pre>","tags":["SQLite"]},{"location":"sql/query/#crud","title":"CRUD","text":"<p>El acr\u00f3nimo CRUD representa las operaciones b\u00e1sicas sobre las bases de datos:</p> <ul> <li>crear (create);</li> <li>leer (read);</li> <li>modificar (update);</li> <li>eliminar (delete).</li> </ul>","tags":["SQLite"]},{"location":"sql/query/#comandos-crud","title":"Comandos CRUD","text":"","tags":["SQLite"]},{"location":"sql/query/#crear-create","title":"Crear (create)","text":"<p>Las tablas se crean con el comando <code>CREATE</code>  y en la declaraci\u00f3n se enumera el nombre de tabla como tambi\u00e9n el nombre y tipo de cada campo a incluir en la misma.</p> <p>Por ejemplo, la creaci\u00f3n de una tabla llamada usuarios que incluya como atributos el nombre, apellido y la edad de cada usario se puede hacer as\u00ed:</p> Create<pre><code>-- declaraci\u00f3n\nCREATE TABLE \"usuarios\" (\n    -- atributos\n    \"nombre\"    TEXT,\n    \"apellido\"  TEXT,\n    \"edad\"  INTEGER\n);\n</code></pre> <p>Fin de instrucci\u00f3n</p> <p>El punto y coma (<code>;</code>) indica el final de cada intrucci\u00f3n.</p>","tags":["SQLite"]},{"location":"sql/query/#actualizar-update","title":"Actualizar (update)","text":"<p>Los datos se actualizan con el comando <code>INSERT</code>.</p> <p>Ejemplo: cargar datos de un usuario (un registro):</p> Update - un registro<pre><code>-- eleccion de tabla\nINSERT INTO usuarios (nombre, apellido, edad)\n-- valores de registro a incluir\nVALUES ('Aitor','Tilla', 47) ;\n</code></pre> <p>Para delimitar los valores de texto se pueden usar comillas simples (<code>'</code>) o dobles (<code>\"</code>). Se recomienda el uso de las comillas simples.</p> <p>Cargar datos de multiples registros:</p> Update - multiples registros<pre><code>-- eleccion de tabla\nINSERT INTO usuarios (nombre, apellido, edad)\n-- valores de registros a incluir\nVALUES  ('Aitor','Tilla', 47),\n        ('Aquiles','Brinco', 25),\n        ('Helen', 'Chufe', 31),\n        ('Susana', 'Torio', 55);\n</code></pre> <p>Prestar atencion al uso de comas para separar registros.</p> <p>Datos repetidos</p> <p>Los registros que se repitan ser\u00e1n guardados m\u00faltiples veces.</p>","tags":["SQLite"]},{"location":"sql/query/#leer-read","title":"Leer (read)","text":"<p>La lectura de campos y de tablas se realizan con el comando <code>SELECT</code>.</p> <p>Siguiendo el ejemplo previo, si se necesita leer todo el contenido de la tabla:</p> Read - tabla completa<pre><code>-- lectura todos los campos (*)\nSELECT * FROM usuarios;\n</code></pre> id_usuario nombre apellido edad 1 Aitor Tilla 47 2 Aquiles Brinco 25 3 Helen Chufe 31 4 Susana Torio 55 <p>Si en cambio se busca leer algunos campos particulares de una tabla:</p> Read - campos espec\u00edficos<pre><code>-- lectura de campos espec\u00edficos desde tabla\nSELECT nombre, edad FROM usuarios ;\n</code></pre> nombre edad Aitor 47 Aquiles 25 Helen 31 Susana 55 <p>Los campos elegidos se separan con comas.</p>","tags":["SQLite"]},{"location":"sql/query/#eliminar-delete","title":"Eliminar (delete)","text":"<p>Las tablas se eliminan con el comando <code>DELETE</code>.</p> <p>Por ejemplo, para eliminar una tabla de usuarios:</p> Delete - tabla completa<pre><code>-- Eliminar tabla\nDELETE FROM usuarios ;\n</code></pre>","tags":["SQLite"]},{"location":"sql/recaudacion/","title":"Ejercicio Integrador - Recaudaci\u00f3n","text":"<p>A modo de integraci\u00f3n se propone crear las consultas necesarias para calcular los montos de recaudaci\u00f3n descritos en la base de datos NorthWind.</p> <p>Se eligen los siguientes criterios:</p> <ul> <li>Por recaudaci\u00f3n seg\u00fan cada producto.</li> <li>Por recaudaci\u00f3n seg\u00fan cada empleado de la tienda.</li> </ul>"},{"location":"sql/recaudacion/#1-tablas-relevantes","title":"1. Tablas relevantes","text":"<p>Se describen las tablas de la base de datos que tienen informaci\u00f3n importante para los ejercicios y se enumeran los campos de inter\u00e9s de cada una.</p>"},{"location":"sql/recaudacion/#orders","title":"<code>Orders</code>","text":"<p>Hay 196 \u00f3rdenes de compra en total, las cuales pueden agrupar distintos productos (no especificados aqu\u00ed)  y cada una es manejada por un empleado particular.</p> <pre><code>Orders:\n    - OrderID   \n    - EmployeeID    \n</code></pre>"},{"location":"sql/recaudacion/#orderdetails","title":"<code>OrderDetails</code>","text":"<p>Las \u00f3rdenes se desglosan en 518 \"detalles de orden\". Cada uno consiste en un producto elegido para comprar y su cantidad pedida. </p> <pre><code>OrderDetails:\n    - OrderDetailID \n    - OrderID   \n    - ProductID \n    - Quantity\n</code></pre>"},{"location":"sql/recaudacion/#products","title":"<code>Products</code>","text":"<p>El cat\u00e1logo de productos (77 en total) tiene su propia tabla, donde se incluye el nombre y precios de cada uno. </p> <pre><code>Products:\n    - ProductID\n    - ProductName\n    - Price\n</code></pre>"},{"location":"sql/recaudacion/#employees","title":"<code>Employees</code>","text":"<p>Los datos de todos los empleados son condensados en esta tabla. Son 10 personas contratadas.</p> <pre><code>Employees:\n    - EmployeeID\n    - LastName\n    - FirstName\n</code></pre>"},{"location":"sql/recaudacion/#2-agrupar-detalles-de-ordenes","title":"2. Agrupar detalles de \u00f3rdenes","text":"<p>Se extiende la tabla <code>OrderDetails</code>  agregando los precios de cada producto elegido mediante una uni\u00f3n <code>INNER JOIN</code> y se crea una vista de dicha consulta,  llam\u00e1ndola <code>OrderDetailsExtended</code> :</p> <pre><code>-- Creaci\u00f3n de vista\nCREATE VIEW IF NOT EXISTS OrderDetailsExtended AS \n-- inner join implicita\nSELECT  OrderDetailID, \n    OrderID, \n    P.ProductID, \n    Quantity, \n    Price ,\n    Quantity * Price AS ProductOrderRevenue \nFROM OrderDetails OD, Products P\nWHERE OD.ProductID=P.ProductID\n</code></pre> <p>Esta vista puede consultarse como una tabla cualquiera:</p> <pre><code>SELECT * FROM OrderDetailsExtended\n</code></pre> OrderDetailID OrderID ProductID Quantity Price ProductOrderRevenue 1 10248 11 12 21 252 2 10248 42 10 14 140 3 10248 72 5 34.8 174.0 ... ... ... ... ... ... 517 10443 11 6 21 126 518 10443 28 12 45.6 547.2"},{"location":"sql/recaudacion/#3-recaudacion-por-producto","title":"3. Recaudaci\u00f3n por producto","text":"<p>Con una consulta se calcula el total de dinero recaudado con cada producto en venta y se le asigna la lista <code>ProductsRevenue</code>. Usa los datos de la vista <code>OrderDetailsExtended</code>  y le agrega el nombre de cada producto mediante una  uni\u00f3n <code>LEFT JOIN</code></p> <pre><code>CREATE VIEW IF NOT EXISTS ProductsRevenue AS\n\nSELECT \n    P.ProductID, \n    ProductName, \n    SUM(ProductOrderRevenue) AS ProductRevenue\nFROM Products P\nLEFT JOIN OrderDetailsExtended ODE\nON P.ProductID=ODE.ProductID\nGROUP BY P.ProductID\n</code></pre> <pre><code>SELECT * FROM ProductsRevenue\n</code></pre> ProductID ProductName ProductRevenue 1 Chais 2862 2 Chang 6479 3 Aniseed Syrup 800 4 Chef Anton's Cajun Seasoning 2354 ... ... ... 76 Lakkalik\u00f6\u00f6ri 3564 77 Original Frankfurter gr\u00fcne So\u00dfe 1404"},{"location":"sql/recaudacion/#4-recaudacion-por-empleado","title":"4. Recaudaci\u00f3n por empleado","text":"<p>La vista <code>OrderDetailsExtended</code> se une con la tabla <code>Orders</code>.  Esto permitir\u00e1 agregar la informaci\u00f3n de los empleados y se usa la agregaci\u00f3n para calcular los totales de ingresos correspondientes a cada empleado, creando la vista <code>EmployeesSales</code>:</p> <p><pre><code>-- Creaci\u00f3n de vista\nCREATE VIEW IF NOT EXISTS EmployeesSales AS \n\nSELECT    \n    -- ID de cada empleado con ingresos\n    EmployeeID,\n    -- suma por ventas de cada empleado\n    SUM(ProductOrderRevenue) AS EmployeeSales\n    -- inner join implicita\n    FROM OrderDetailsExtended ODE, Orders O\nWHERE ODE.OrderID=O.OrderID\n-- agregacion por ID de empleado empleado\nGROUP BY EmployeeID\nORDER BY EmployeeID\n</code></pre> De esta forma se muestran todas las recaudaciones y a qu\u00e9 empleado le corresponde cada una:</p> <pre><code>SELECT * FROM EmployeesSales \n</code></pre> EmployeeID EmployeeSales 1 57690.39 2 32503.16 3 42838.35 4 105696.5 5 27480.8 6 25399.25 7 39772.3 8 39309.38 9 15734.1 <p>Con una <code>LEFT JOIN</code> se puede forzar la visualizaci\u00f3n de todos los empleados  y a cada uno se le asigna el valor de ventas conseguido:</p> <pre><code>-- Creaci\u00f3n de vista\nCREATE VIEW IF NOT EXISTS EmployeesRevenue AS \n\nSELECT \n    E.EmployeeID,\n    FirstName ||\" \"||LastName AS Employee,\n    EmployeeSales \nFROM  Employees E\n-- se muestra a todos los empleados\nLEFT JOIN EmployeesSales  S \nON S.EmployeeID=E.EmployeeID\nORDER BY E.EmployeeID\n</code></pre> <p>La vista creada se llam\u00f3 <code>EmployeesRevenue</code> y se consulta para ver el resultado</p> <p><pre><code>SELECT * FROM EmployeesRevenue \n</code></pre> Este es el resultado final:</p> EmployeeID Employee EmployeeSales 1 Nancy Davolio 57690.39 2 Andrew Fuller 32503.16 3 Janet Leverling 42838.35 4 Margaret Peacock 105696.5 5 Steven Buchanan 27480.8 6 Michael Suyama 25399.25 7 Robert King 39772.3 8 Laura Callahan 39309.38 9 Anne Dodsworth 15734.1 10 Adam West"},{"location":"sql/recaudacion/#5-conexion-con-python","title":"5. Conexion con Python","text":"<p>Descarga de rutina Python \"recaudar.py\" </p> Ver c\u00f3digo de rutina Python"},{"location":"sql/subconsultas/","title":"Subconsultas (Subqueries)","text":"<p>Las subconsultas son consultas auxiliares cuyo resultado servir\u00e1 para hacer una consulta de mayor jerarqu\u00eda:</p> <pre><code>SELECT (SELECT ...) ...\nINSERT INTO (SELECT) ...\nUPDATE (SELECT ...) ...\n-- (etc)\n</code></pre> <p>Las subconsultas son de s\u00f3lo lectura (comando <code>SELECT</code>),  por ello no pueden modificar los datos guardados por s\u00ed mismas.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/subconsultas/#orden","title":"Orden","text":"<p>El orden de la subconsulta es la cantidad de subconsultas anidadas.  Si hay una es orden 1, si hay dos es orden dos, etc.  Cada gestor de bases de datos impone su propio l\u00edmite al orden de las subconsultas admisibles.</p> <p>EL est\u00e1ndar SQL impone un m\u00e1ximo de 16 subconsultas,  pero hay gestores que soportan muchas m\u00e1s.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/subconsultas/#tipos","title":"Tipos","text":"<p>Las subqueries pueden clasificarse por tipos seg\u00fan resultado buscado:</p> <ul> <li>subconsultas de valor unico</li> <li>subconsultas de fila</li> <li>subconsultas de tabla</li> </ul> <p>Tambi\u00e9n pueden clasificarse seg\u00fan su correlacion con la tabla principal:</p> <ul> <li>correlacionales</li> <li>no correlacionales</li> </ul> <p>Sin embargo, en el lenguaje coloquial rara vez se especifica qu\u00e9 tipo de subconsulta se us\u00f3 en cada caso.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/subconsultas/#uso","title":"Uso","text":"<p>Se consultan los productos y cantidades de la tabla de pedidos, llamada <code>OrderDetails</code>...</p> <pre><code>-- 518 \u00f3rdenes, un producto por orden\nSELECT ProductID,Quantity AS Cantidad FROM OrderDetails \n</code></pre> <p>... pero se devuelven los IDs de los productos, no su nombre:</p> ProductID Cantidad 11 12 42 10 72 5 ... ... <p>\u00c9ste se encuentra en otra tabla llamada <code>Products</code>.</p> <pre><code>-- 77 productos en el cat\u00e1logo\nSELECT ProductID, ProductName AS Nombre FROM Products \n</code></pre> ProductID Nombre 1 Chais 2 Chang 3 Aniseed Syrup 4 Chef Anton's Cajun Seasoning ... ... <p>La \u00faltima instrucci\u00f3n se agrega adentro de la primera como subconsulta:</p> <p><pre><code>SELECT \n    ProductID,\n    Quantity, \n    -- Subconsulta a la tabla 'Products'\n    (SELECT ProductName FROM Products) AS Nombre    -- MAL: nombre producto err\u00f3neo \nFROM OrderDetails;\n</code></pre> ... pero a todos los productos les asigna el nombre 'Chais',  que es el nombre del primer producto. Se agrega a la subconsulta la condici\u00f3n para acoplar los registros de ambas tablas, que es la coincidencia entre ambas tablas del valor del campo <code>ProductID</code>: </p> <p>Subconsulta<pre><code>-- Consulta a la tabla 'OrderDetails'\nSELECT ProductID as pID,\n    Quantity as Cantidad, \n    -- Subconsulta a la tabla 'Products'- con condici\u00f3n de acoplamiento\n    (SELECT ProductName FROM Products \n    WHERE OrderDetails.ProductID = ProductID) AS Producto\nFROM OrderDetails;\n</code></pre> dando por resultado la combinaci\u00f3n correcta de cantidades y nombres para cada pedido registrado:</p> pID Cantidad Producto 11 12 Queso Cabrales 42 10 Singaporean Hokkien Fried Mee 72 5 Mozzarella di Giovanni ... ... ...","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/subconsultas/#alias-de-tabla","title":"Alias de tabla","text":"<p>Las tablas obtenidas pueden tener un alias,  un nombre alternativo para poder consultarlas. Este alias se crea con ayuda del operador <code>AS</code> o con el uso de corchetes:</p> Alias - operador AS<pre><code>-- (operaciones previas)\nFROM OrderDetails AS Od -- operador 'AS'\n</code></pre> Alias - con corchetes<pre><code>-- (operaciones previas)\n-- ...\nFROM [OrderDetails]  Od -- corchetes\n</code></pre> <p>En el ejemplo se repite la subconsulta previa implementando un alias para la tabla de salida:</p> Subconsulta - Alias de tabla<pre><code>-- Consulta a la tabla 'OrderDetails'\nSELECT ProductID,\n        Quantity, \n        -- Subconsulta a la tabla 'Products'\n        (SELECT ProductName FROM Products AS Prod\n        WHERE Od.ProductID = ProductID) AS Nombre \nFROM OrderDetails AS Od -- 'Od': alias de tabla\n</code></pre>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/subconsultas/#multiples-subconsultas","title":"M\u00faltiples subconsultas","text":"<p>Una misma consulta puede incluir varias subconsultas internas.</p> <p>En el ejemplo se consultan el nombre de cada producto y precio por separado:</p> Doble subconsulta - producto y precio<pre><code>-- Consulta a tabla\nSELECT ProductID,\n        Quantity AS Cantidad, \n        -- Subconsulta N\u00ba1 a la tabla 'Products': nombre producto\n        (SELECT ProductName FROM Products \n        WHERE Od.ProductID = ProductID) AS Producto,\n        -- Subconsulta N\u00ba2 a la tabla 'Products': precio\n        (SELECT Price FROM Products\n        WHERE Od.ProductID = ProductID) AS Precio \nFROM OrderDetails AS Od\n</code></pre> <p>Este es el resultado:</p> ProductID Cantidad Producto Precio 11 12 Queso Cabrales 21 42 10 Singaporean Hokkien Fried Mee 14 72 5 Mozzarella di Giovanni 34.8 14 9 Tofu 23.25 ... ... ... ...","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/subconsultas/#subconsultas-de-orden-superior","title":"Subconsultas de orden superior","text":"<p>Las subconsultas de orden superior se consiguen anidando subconsultas.</p> <p>En este ejemplo, se consulta el precio de los productos para poder calcular el dinero recaudado por producto (<code>cantidad * precio</code>)</p> subconsulta orden superior - recaudacion por producto<pre><code>SELECT ProductID, \n    SUM(Quantity) as Cantidad,\n    --  subconsulta de primer orden: precio\n    (SELECT Price FROM Products \n    WHERE ProductID =  OD.ProductID) AS Precio,\n    --  subconsulta de segundo orden: total recaudado por ventas\n    SUM(Quantity)*(\n        -- sub-subconsulta: precios de cada producto\n        SELECT Price FROM Products \n            WHERE ProductID =  OD.ProductID\n            ) AS Total_Recaudado\n    FROM OrderDetails AS OD\nGROUP BY ProductID\nORDER BY Total_Recaudado DESC\n</code></pre> <p>Resultado:</p> ProductID Cantidad Precio Total_Recaudado 38 239 263.5 62976.5 29 168 123.79 20796.72 59 346 55 19030 ... ... ... ... <p>Si al ejemplo previo se le agrega una nueva subconsulta se puede adjuntar tambi\u00e9n el nombre de cada producto: </p> ejemplo integrador - producto, precio y recaudaci\u00f3n<pre><code>SELECT ProductID, \n    -- Subconsulta N\u00ba1 a la tabla 'Products': nombre producto\n    (SELECT ProductName FROM Products WHERE ProductID = OD.ProductID) as Producto,\n    -- Subconsulta N\u00ba2 a la tabla 'Products': precio\n    (SELECT Price FROM Products WHERE ProductID = OD.ProductID) as Precio,\n    SUM(Quantity) AS Cantidad,\n    --  Subconsulta N\u00ba3 a la tabla 'Products' (segundo orden): total recaudado por ventas\n    (SUM(Quantity) * (\n        -- sub-subconsulta: precios de cada producto\n        SELECT Price FROM Products WHERE ProductID = OD.ProductID)\n        ) AS Total_Recaudado\nFROM [OrderDetails] OD\nGROUP BY ProductID  \nORDER BY total_recaudado DESC;\n</code></pre> <p>Resultado:</p> ProductID Producto Precio Cantidad Total_Recaudado 38 C\u00f4te de Blaye 263.5 239 62976.5 29 Th\u00fcringer Rostbratwurst 123.79 168 20796.72 59 Raclette Courdavault 55 346 19030 ... ... ... ... ...","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/subconsultas/#ejemplos-adicionales","title":"Ejemplos adicionales","text":"Ordenado de empleados por N\u00ba de ventas <p>Esta consulta cuenta el total de objetos vendidos por cada empleado.</p> <pre><code>SELECT FirstName,LastName,\n(\n    SELECT SUM(od.Quantity) FROM [orders] o, [OrderDetails]  od\n    WHERE o.EmployeeID = e.EmployeeID AND od.OrderID=o.orderID\n) AS unidades_totales\nFROM [Employees] e\n</code></pre> <p>Hay 10 empleados en la tienda:</p> FirstName LastName unidades_totales Nancy Davolio 1924 Andrew Fuller 1315 Janet Leverling 1725 Margaret Peacock 3232 Steven Buchanan 778 Michael Suyama 1094 Robert King 733 Laura Callahan 1293 Anne Dodsworth 649 Adam West Null <p>(el \u00faltimo no tiene ninguna venta registrada a su nombre) </p> Empleados que vendieron m\u00e1s de la media <pre><code>SELECT FirstName, LastName, (\n        -- subquerie: ventas por empleado\n        SELECT SUM(od.Quantity) FROM [orders] o, [OrderDetails]  od\n        WHERE o.EmployeeID = e.EmployeeID AND od.OrderID=o.orderID\n    ) AS unidades_totales\nFROM [Employees] e\n-- secci\u00f3n filtrado --&gt; media sobre tabla virtual\nWHERE unidades_totales &lt; ( \n    -- c\u00e1lculo de la media de ventas por empleado\n    SELECT AVG(unidades_totales) FROM (\n        SELECT (\n            -- subquerie: ventas por empleado\n            SELECT SUM(od.Quantity) FROM [orders] o, [OrderDetails] od\n            WHERE o.EmployeeID=e2.EmployeeID AND  od.orderID=o.orderID\n            ) AS unidades_totales\n        FROM  [Employees] e2\n        GROUP BY e2.EmployeeID\n        )\n    )\n</code></pre> <p>Hay 6 empleados cuya cantidad de ventas supera la media:</p> FirstName LastName unidades_totales Andrew Fuller 1315 Steven Buchanan 778 Michael Suyama 1094 Robert King 733 Laura Callahan 1293 Anne Dodsworth 649 <p>N\u00f3tese que la subconsulta del ejemplo previo debi\u00f3 repetirse dos veces para obtener el resultado final. Una alternativa superadora a las subqueries son las uniones o joins, que se explican m\u00e1s adelante.</p>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/tabla_datos/","title":"Tabla","text":"<p>La tabla es el formato usado por las bases de datos relacionales para alojar y organizar los datos internos. Los datos se reparten en campos y registros:</p> <ul> <li>Campo es una columna de la tabla;</li> <li> <p>Registro es una fila de la tabla.</p> </li> <li> <p>tipos de datos:</p> </li> </ul> Tipo Descripci\u00f3n <code>INT</code> n\u00fameros enteros <code>TEXT</code> campos de texto <code>BLOB</code> datos binarios: archivos, im\u00e1genes, etc. <code>REAL</code> N\u00fameros flotantes - uso general <code>NUMERIC</code> N\u00fameros flotantes - alta precisi\u00f3n <p><code>REAL</code> usa 8 bytes, <code>NUMERIC</code> es un tipo de datos compuesto, permite manejar n\u00f1umeros mucho m\u00e1s grandes y de mayor precisi\u00f3n  pero es m\u00e1s lento de procesar.</p> <p>Tipado dinamico</p> <p>A diferencia de otros gestores, SQLite permite tipos de datos din\u00e1mico.  Sin embargo esto es considerado una mala pr\u00e1ctica.</p> <ul> <li>Valores por defecto</li> <li>Primary key</li> </ul>","tags":["SQLite","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/udf/","title":"Funciones Definidas por el Usuario (UDF)","text":"","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/udf/#funciones-definidas-por-el-usuario-udf","title":"Funciones Definidas por el Usuario (UDF)","text":"<p>Las User Defined Functions son funciones que se dise\u00f1an en el lenguaje anfitri\u00f3n del programa cliente y se transmiten al gestor de la base de datos.  Es entonces el gestor el encargado de ejecutar la funci\u00f3n indicada por el programa cliente y devolver el resultado en caso de ser requerido.</p>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/udf/#uso-en-python","title":"Uso en Python","text":"<p>El conector sqlite3 incorpora el m\u00e9todo <code>create_function()</code> para crear las UDF. En \u00e9l debe pasarse como argumento un nombre para la funci\u00f3n,  el n\u00famero de argumentos que usar\u00e1  y la funci\u00f3n lambda que define su funcionamiento interno.</p> UDF - definici\u00f3n<pre><code># funci\u00f3n lambda  de inter\u00e9s \ncubo = lambda n : n*n*n\n\n# Funcion de usuario:\n# argumentos: \n# 1 - nombre de la \"funcion de usuario\"\n# 2 - numero de argumentos\n# 3 - funcion lambda a ejecutar\nconector.create_function(\"cube\",1, cubo)\n</code></pre> <p>La funci\u00f3n de usuario as\u00ed creada se usa normalmente dentro de la rutina SQL de la consulta:</p> UDF - uso<pre><code># inicio de transacci\u00f3n (BEGIN impl\u00edcito)\ncursor.execute(\n    # Rutina SQL, consulta de campos con funcion usuario\n    '''\n    SELECT ProductName, \n        Price, \n        round( cube(Price) , 2) AS CubicPrice \n    FROM Products;\n    '''\n    )\n\n# respuesta de la base de datos\nresultados = cursor.fetchall()\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/","title":"Uniones (joins)","text":"<p>Los joins permiten combinar los datos de dos o m\u00e1s tablas y devolverlos en una sola. Trabajan mediante \u00edndices y son una alternativa m\u00e1s eficiente a las subconsultas.</p> <p>Tipos de uniones:</p> <ul> <li>Inner join</li> <li>Left join</li> <li>Right join</li> <li>Full join</li> <li>Cross join</li> </ul>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#inner-join","title":"Inner join","text":"<p>Los <code>INNER JOIN</code> devuelven las coincidencias entre tablas.</p> INNER JOIN - impl\u00edcito<pre><code>-- Tabla de empleados y tabla de \u00f3rdenes de compra\nSELECT * FROM Employees e, orders o\n-- (Inner join implicito)\n-- Condici\u00f3n de uni\u00f3n\nWHERE e.EmployeeID = o.EmployeeID \n</code></pre> INNER JOIN - expl\u00edcito<pre><code>-- Tabla de empleados y tabla de \u00f3rdenes de compra\nSELECT * FROM Employees e\n-- Inner join explicito\nINNER JOIN Orders o\n-- Condici\u00f3n de uni\u00f3n\nON e.EmployeeID = o.EmployeeID \n</code></pre> <p>Uni\u00f3n predefinida</p> <p>El <code>INNER JOIN</code> es la opcion por defecto.  Si s\u00f3lo se indica <code>JOIN</code> se asume que es del tipo <code>INNER</code>.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#cross-join","title":"Cross join","text":"<p>El <code>CROSS JOIN</code> combina todos elementos de una tabla con todos los elementos de la otra.  Si una tabla tiene <code>n</code> registros y la otra tiene <code>m</code> registros  entonces la tabla final tendr\u00e1 <code>n x m</code> registros en total.</p> CROSS JOIN - impl\u00edcito<pre><code>-- Cross join\nSELECT * FROM Employees e, Orders o\n</code></pre> CROSS JOIN - expl\u00edcito<pre><code>-- Cross join\nSELECT * FROM Employees e\nCROSS JOIN Orders o\n</code></pre> <p>El <code>CROSS JOIN</code> rara vez es usado.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#left-join","title":"Left join","text":"<p>El <code>LEFT JOIN</code> muestra la tabla izquierda en su totalidad pero le agrega los datos comunes con la segunda tabla.  A los registros no coincidentes los rellena con <code>Null</code>.</p> LEFT JOIN<pre><code>-- Left join\nSELECT * FROM Employees e\nLEFT JOIN Orders o\nON e.EmployeeID = o.EmployeeID \n</code></pre>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#right-join","title":"Right Join","text":"<p>Es el contrario de <code>LEFT JOIN</code>:  muestra en su totalidad la segunda tabla  y le a\u00f1ade los elementos coincidentes con la primera.</p> <p>SQLite no permite crear la <code>RIGHT JOIN</code> directamente.  Sin embargo se puede implementar invirtiendo el orden de llamado de las tablas:</p> RIGHT JOIN<pre><code>-- 'Right join' simulado\nSELECT * FROM Orders o\nLEFT JOIN Employees e\nON o.EmployeeID = e.EmployeeID \n</code></pre>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#full-join","title":"Full join","text":"<p>La <code>FULL JOIN</code> equivale a la superposici\u00f3n de la <code>LEFT JOIN</code> con la <code>RIGHT JOIN</code>.</p> <p>SQLite no permite crear la <code>FULL JOIN</code> directamente.  Sin embargo se puede implementar con el comando <code>UNION</code>:</p> <p>FULL JOIN<pre><code>-- FULL JOIN SIMULADO:\n\n-- 1 - Left join\nSELECT * FROM Employees e\nLEFT JOIN Orders o\nON e.EmployeeID = o.EmployeeID \n\n-- 3 - union de joints\nUNION\n\n-- 2 - 'Right join' simulado\nSELECT * FROM Orders o\nLEFT JOIN Employees e\nON o.EmployeeID = e.EmployeeID \n</code></pre> El comando <code>UNION</code> muestra la uni\u00f3n l\u00f3gica de las tablas sin repetir elementos.  Para mostrar tambi\u00e9n los registros repetidos usar <code>UNION ALL</code>.</p> <p>Para que la uni\u00f3n funcione correctamente, las dos tablas deben tener los mismos campos;  de otra manera se puede dar lugar a resultados impredecibles.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#ejemplo-aplicado","title":"Ejemplo aplicado","text":"","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#preparando-data","title":"Preparando data","text":"<p>Imag\u00ednese que se otorgan premios mensuales para los empleados. Estos se guardan en una nueva tabla llamada <code>Rewards</code>:</p> Tabla de premios<pre><code>-- Tabla de premios para los empleados\nCREATE TABLE \"Rewards\"(\n    \"RewardID\" INTEGER,\n    \"EmployeeID\" INTEGER,\n    \"Reward\" INTEGER,\n    \"Month\" TEXT,\n    PRIMARY KEY (\"RewardID\" AUTOINCREMENT)\n);\n</code></pre> <p>Los registros de los premios se cargan en la nueva tabla:</p> Registro de premios<pre><code>-- Registro de premios: uno por mes\nINSERT INTO Rewards (EmployeeID, Reward, Month) VALUES\n(3, 200, \"Juanuary\"),\n(2, 180, \"February\"),\n(5, 250, \"March\"),\n(1, 280, \"April\"),\n(8, 160,\"May\"),\n(null, null, \"June\");   -- premio no asignado\n</code></pre> <p>El resultado se consulta </p> <p>Ver premios<pre><code>-- ver resultado\nSELECT * FROM Rewards;\n</code></pre> Esta es la tabla creada:</p> RewardID EmployeeID Reward Month 1 3 200 Juanuary 2 2 180 February 3 5 250 March 4 1 280 April 5 8 160 May 6 June <p>El \u00faltimo premio no fue entregado, por ello el monto y el ID de empleado aparecen vac\u00edos.</p> <p>Con la tabla ya configurada  y usando uniones se puede consultar la data relacionada con los premios. En este ejemplo se tomo como tabla izquierda la tabla de empleados (<code>Employees</code>)  y como tabla derecha la tabla de premios (<code>Rewards</code>).</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#inner-join_1","title":"Inner join","text":"<p>Esta uni\u00f3n muestra solamente a aquellos empleados premiados y la informaci\u00f3n de su premio.</p> Empleados premiados<pre><code>-- inner join: empleados premiados, recompensa y mes entrega\nSELECT e.EmployeeID, FirstName , Reward, Month FROM Employees e\nINNER JOIN Rewards r\nON r.EmployeeID = e.EmployeeID\n</code></pre> EmployeeID FirstName Reward Month 3 Janet 200 Juanuary 2 Andrew 180 February 5 Steven 250 March 1 Nancy 280 April 8 Laura 160 May <p>N\u00f3tese la necesidad de indicar una de las tablas de origen para poder mostrar el campo <code>EmployeeID</code>. Esto se debe a que aparece en ambas tablas y entonces SQLite arroja un error por ambiguedad de columna ( 'ambiguous column name').</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#left-join_1","title":"Left join","text":"<p>Esta uni\u00f3n muestra a todos los empleados y la informaci\u00f3n de sus premios,  si es que recibieron algo.</p> Todos los empleados<pre><code>-- left join: todos los empleados y qu\u00e9 premio recibi\u00f3 cada uno, si recibi\u00f3 algo\nSELECT e.EmployeeID, FirstName , Reward, Month FROM Employees e\nLEFT JOIN Rewards r\nON r.EmployeeID = e.EmployeeID\n</code></pre> EmployeeID FirstName Reward Month 1 Nancy 280 April 2 Andrew 180 February 3 Janet 200 Juanuary 4 Margaret 5 Steven 250 March 6 Michael 7 Robert 8 Laura 160 May 9 Anne 10 Adam","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#right-join_1","title":"Right join","text":"<p>Con esta uni\u00f3n se muestran todos los premios y a qui\u00e9n le fueron asignados.</p> Todos los premios<pre><code>-- 'right join': todos los premios y qu\u00e9 empleados fueron beneficiados\nSELECT e.EmployeeID, FirstName , Reward, Month FROM Rewards r\nLEFT JOIN Employees e \nON e.EmployeeID = r.EmployeeID\n</code></pre> EmployeeID FirstName Reward Month 3 Janet 200 Juanuary 2 Andrew 180 February 5 Steven 250 March 1 Nancy 280 April 8 Laura 160 May June","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uniones/#full-join_1","title":"Full join","text":"<p>Esta uni\u00f3n muestra a todos los empleados y a todos los premios vinculados entre s\u00ed.</p> Todos los empleados, todos los premios<pre><code>-- left join: todos los empleados y qu\u00e9 premio recibi\u00f3 cada uno, si recibi\u00f3 algo\nSELECT e.EmployeeID, FirstName , Reward, Month FROM Employees e\nLEFT JOIN Rewards r\nON r.EmployeeID = e.EmployeeID\n\n-- full join (l + r) : todos los empleados, todos los premios\nUNION\n\n-- 'right join': todos los premios y qu\u00e9 empleados fueron beneficiados\nSELECT e.EmployeeID, FirstName , Reward, Month FROM Rewards r\nLEFT JOIN Employees e \nON e.EmployeeID = r.EmployeeID\n</code></pre> EmployeeID FirstName Reward Month June 1 Nancy 280 April 2 Andrew 180 February 3 Janet 200 Juanuary 4 Margaret 5 Steven 250 March 6 Michael 7 Robert 8 Laura 160 May 9 Anne 10 Adam <p>Aparecen tanto los empleados sin premios como el premio sin asignar.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/","title":"Uso en Python","text":"","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#importacion","title":"Importaci\u00f3n","text":"<p>Python puede conectarse con SQLite mediante el conector sqlite3, el cual debe importarse:</p> SQLite3 - importaci\u00f3n<pre><code>import sqlite3\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#conectores-y-cursores","title":"Conectores y cursores","text":"<p>Se crea un conector que abre el archivo que almacena la base de datos:</p> SQLite3 - conector<pre><code># ejemplo: archivo de base de datos aleda\u00f1o al ejecutable\nruta_archivo = \"Northwind.db\"\n\n# conexion con  base de datos en archivo\nconector = sqlite3.connect(ruta_archivo)\n</code></pre> <p>El siguiente paso es crear un cursor para manejar pedidos y respuestas de SQLite:</p> SQLite3 - cursor<pre><code># Cursor \ncursor = conector.cursor()\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#consultas-y-transacciones","title":"Consultas y transacciones","text":"<p>Para hacer las consultas se usa el m\u00e9todo <code>execute()</code>,  el cual siempre crea una transacci\u00f3n.  Las instrucciones de SQL se ingresan como argumento en formato texto.</p>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#lectura","title":"Lectura","text":"<p>SQlite3 - consultar<pre><code># inicio de transacci\u00f3n (BEGIN impl\u00edcito)\ncursor.execute(\n    # Rutina SQL, 1 renglon\n    'SELECT ProductName, Price FROM Products;'\n    )\n</code></pre> La respuesta del gestor se recibe con el m\u00e9todo <code>fetchall()</code>: SQlite3 - leer respuesta<pre><code>#respuesta de la base de datos\nresultados = cursor.fetchall()\nprint(resultados)\n</code></pre> La respuesta viene dada como una lista de tuplas que contienen los registros. </p>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#modificar-datos","title":"Modificar datos","text":"<p>Si se busca leer modificar los datos tambi\u00e9n se usa el m\u00e9todo <code>execute()</code>.  Recordar que este m\u00e9todo impl\u00edcitamente inicia una transacci\u00f3n  y por tanto los cambios producidos ser\u00e1n temporales:</p> SQLite - Iniciar transacci\u00f3n<pre><code># inicio de transacci\u00f3n (BEGIN impl\u00edcito)\ncursor.execute(\n    # Consulta SQL: actualizaci\u00f3n de un nombre de producto\n    '''\n    UPDATE Products SET ProductName = \"Chais\" WHERE ProductName = \"El Pollo\" ;\n    '''\n)\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#validacion-y-descarte","title":"Validaci\u00f3n y descarte","text":"<p>La validaci\u00f3n de los cambios introducidos se realiza con el m\u00e9todo <code>commit()</code> en tanto que el descarte de los mismos se realiza con el m\u00e9todo <code>rollback()</code>:</p> SQLite - Confirmaci\u00f3n de cambios<pre><code># guardado definitivo de cambios\nconector.commit()\n</code></pre> SQLite - Descarte de cambios<pre><code># reestablecimiento de datos\nconector.rollback()\n</code></pre> <p>Una posibilidad del uso de \u00e9stos m\u00e9todos es repartirlos entre las rutinas de excepciones ( <code>try</code> - <code>except</code> - <code>else</code> ).  De esta forma se validan los cambios s\u00f3lo si no se produjeron excepciones  y en caso contrario se ordena el reestablecimiento de los datos originales.</p> SQLite - Transacci\u00f3n con excepciones Python<pre><code>try:\n    # inicio de transacci\u00f3n (BEGIN impl\u00edcito)\n    cursor.execute(\n        # Consulta SQL: actualizaci\u00f3n de un nombre de producto\n        '''\n        UPDATE Products SET ProductName = \"Chais\" WHERE ProductName = \"El Pollo\" ;\n        '''\n        )\n\nexcept:\n    # excepci\u00f3n producida: reestablecimiento de datos\n    conector.rollback()\n    print(\"datos reestablecidos\")\n\nelse:\n    # respuesta normal: guardado definitivo de cambios\n    conector.commit()\n    print(\"cambios confirmados\")\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#cierre","title":"Cierre","text":"","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#cierre-manual","title":"Cierre manual","text":"<p>El cierre manual de la base de datos se realiza cerrando tanto el cursor como el conector con el m\u00e9todo <code>close()</code>:</p> SQLite3 - cierre manual<pre><code># cierre\ncursor.close()\nconector.close()\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#cierre-automatico","title":"Cierre autom\u00e1tico","text":"<p>Una alternativa es abrir creando un contexto con la cl\u00e1usula <code>with</code>,  de la misma manera en que suelen abrirse los archivos.  En tal caso el cierre de la base de datos se hace autom\u00e1ticaticamente al salir del contexto creado,  el cual es marcado por indentaci\u00f3n.</p> SQLite3 - cl\u00e1usula with<pre><code>with sqlite3.connect(ruta_archivo) as conector:\n    # Cursor \n    cursor = conector.cursor()\n    # rutina\n    # .....\n\n# cierre autom\u00e1tico\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#extra-pandas-y-mathplotlib","title":"Extra: Pandas y Mathplotlib","text":"","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#pandas","title":"Pandas","text":"<p>Una opci\u00f3n para darle formato de tablas a la informaci\u00f3n en consola es usar la biblioteca pandas. El paquete se instala v\u00eda PIP:</p> Pandas - instalaci\u00f3n<pre><code>pip install pandas\n</code></pre> <p>El paquete se importa para su uso:</p> Pandas - importaci\u00f3n<pre><code>import pandas as pd\n</code></pre> <p>Finalmente el paquete ayuda a dar formato a la data de la consulta  con ayuda de la funci\u00f3n <code>DataFrame()</code>:</p> <p>Pandas - formateo de datos<pre><code>dataframe = pd.DataFrame(resultados)\nprint(dataframe)\n</code></pre> En este caso se mostrar\u00e1 el contenido tabulado en consola emulando una tabla.</p>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#matplotlib","title":"Matplotlib","text":"<p>La biblioteca Mathplotlib permite graficar las tablas formateadas con Pandas con la funci\u00f3n <code>pyplot()</code>. Debe instalarse:</p> Matplotlib - instalaci\u00f3n<pre><code>pip install matplotlib\n</code></pre> <p>El paquete requiere importaci\u00f3n:</p> Matplotlib - importaci\u00f3n<pre><code>import matplotlib.pyplot as plt\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#combinando-paquetes","title":"Combinando paquetes","text":"<p>Pandas incluye integrado su propio manejador para realizar consultas y gestionar el resultado ya formateado:</p> Handler de Pandas<pre><code># Query para el gestor SQL en formato 'string'\nconsulta =  '''\n    SELECT ProductName, Price FROM Products;\n    '''\n# Env\u00edo consulta y recepci\u00f3n de respuesta\ndataframe = pd.read_sql_query(consulta, conector)\n</code></pre> <p>Con el m\u00e9todo <code>plot()</code> de Pandas se configuran los par\u00e1metros de inter\u00e9s de la gr\u00e1fica. \u00c9sta se muestra con la funci\u00f3n <code>show()</code> de Matplotlib:</p> Gr\u00e1fica de barras<pre><code># Pandas - par\u00e1metros de la gr\u00e1fica\ndataframe.plot(\n    x=\"ProductName\",\n    y=\"Price\",\n    kind=\"bar\",\n    figsize=(10, 5), \n    legend = False\n    )\n\n# Matplotlib - Gr\u00e1fica de Barras\nplt.title(\"Precios\")\nplt.xlabel(\"Producto\")\nplt.ylabel(\"Valor\")\nplt.xticks(rotation = 90)   # etiquetas en vertical\nplt.show()\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#ejemplos","title":"Ejemplos","text":"<p>Ejemplo N\u00ba1: consulta de precios - por consola</p> Northwind - Cierre manual<pre><code>import sqlite3\n\n# ejemplo: archivo de base de datos aleda\u00f1o al ejecutable\nruta_archivo = \"Northwind.db\"\n\n# conexion con  base de datos en archivo\nconector = sqlite3.connect(ruta_archivo)\n# Cursor\ncursor = conector.cursor()\n# inicio de transacci\u00f3n (BEGIN impl\u00edcito)\ncursor.execute(\n    # Rutina SQL, 1 renglon\n    'SELECT ProductName, Price FROM Products;'\n    )\n\n#respuesta de la base de datos\nresultados = cursor.fetchall()\nprint(resultados)\n# cierre de conexi\u00f3n\ncursor.close()\nconector.close()\n</code></pre> Northwind - cierre autom\u00e1tico<pre><code>import sqlite3\n\n# ejemplo: archivo de base de datos aleda\u00f1o al ejecutable\nruta_archivo = \"Northwind.db\"\n\nwith sqlite3.connect(ruta_archivo) as conector:\n    # Cursor \n    cursor = conector.cursor()\n    # inicio de transacci\u00f3n (BEGIN impl\u00edcito)\n    cursor.execute(\n        # Rutina SQL, 1 renglon\n        'SELECT ProductName, Price FROM Products;'\n        )\n\n    #respuesta de la base de datos\n    resultados = cursor.fetchall()\n    print(resultados)\n</code></pre> <p>Ejemplo N\u00ba2: consulta de precios - con gr\u00e1ficas</p> <pre><code>import sqlite3\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nruta_archivo = \"Northwind.db\"\n\n# conexion con  base de datos en archivo\nconector = sqlite3.connect(ruta_archivo)\n\n# Query para el gestor SQL en formato 'string'\nconsulta =  '''\n    SELECT ProductName, Price FROM Products;\n    '''\n# Env\u00edo consulta y recepci\u00f3n de respuesta\ndataframe = pd.read_sql_query(consulta, conector)\n\n# par\u00e1metros de la gr\u00e1fica\ndataframe.plot(\n    x=\"ProductName\",\n    y=\"Price\",\n    kind=\"bar\",\n    figsize=(10, 5), \n    legend = False\n    )\n\n# Gr\u00e1fica de Barras\nplt.title(\"Precios\")\nplt.xlabel(\"Producto\")\nplt.ylabel(\"Valor\")\nplt.xticks(rotation = 90)   # etiquetas en vertical\nplt.show()\n</code></pre> <p>Ejemplo N\u00ba3: Actualizaci\u00f3n de datos - con excepciones</p> <pre><code>import sqlite3\n\n# ejemplo: archivo de base de datos aleda\u00f1o al ejecutable\nruta_archivo = \"Northwind.db\"\n\n# conexion con  base de datos en archivo\nwith sqlite3.connect(ruta_archivo) as conector:\n    # Cursor \n    cursor = conector.cursor()\n\n    try:\n        # inicio de transacci\u00f3n (BEGIN impl\u00edcito)\n        cursor.execute(\n            # Modificaci\u00f3n de campo\n            '''\n            UPDATE Products SET ProductName = \"Chais\" WHERE ProductName = \"El Pollo\" ;\n            '''\n            )\n    except:\n        # reestablecimiento de datos\n        conector.rollback()\n        print(\"datos reestablecidos\")\n\n    else:\n        # guardado definitivo de cambios\n        conector.commit()\n        print(\"cambios confirmados\")\n</code></pre>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/uso_python/#referencias","title":"Referencias","text":"<p>Soy Dalto - Curso de SQL desde CERO (Completo)</p>","tags":["Python","SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/vistas/","title":"Vistas","text":"<p>Las vistas son tablas auxiliares que hacen referencia a las tablas de datos.  Sirven para facilitar la visualizaci\u00f3n de datos recolectados de otras tablas.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/vistas/#creacion","title":"Creaci\u00f3n","text":"<p>Creaci\u00f3n de la vista: <pre><code>-- Creaci\u00f3n de vista\nCREATE VIEW Productos_simplificados AS \n-- Consulta equivalente\nSELECT ProductID, ProductName, Price FROM Products\nWHERE ProductID &gt; 20\nORDER BY ProductID DESC  \n</code></pre></p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/vistas/#lectura","title":"Lectura","text":"<p>Lectura de la vista: <pre><code>SELECT * FROM  Productos_simplificados\n</code></pre></p> <p>Visibilidad</p> <p>Si se crea una vista con igual nombre que una tabla, la vista tendr\u00e1 prioridad de consulta respecto a la tabla.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]},{"location":"sql/vistas/#eliminacion","title":"Eliminaci\u00f3n","text":"<p>Eliminaci\u00f3n de vistas:</p> <p><pre><code>DROP VIEW IF EXISTS Productos_simplificados\n</code></pre> La condici\u00f3n <code>IF EXISTS</code> es recomendable para evitar posibles errores en caso que la vista ya haya sido eliminada.</p> <p>Abuso de vistas</p> <p>Las vistas son consultas y como tales exigen capacidad de procesamiento. No abusar de su uso.</p>","tags":["SQLite","SQLAlchemy","MySQL","PostgreSQL","MariaDB"]}]}